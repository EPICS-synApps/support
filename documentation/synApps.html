<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<title>synApps</title>
</head>

<body bgcolor="#FFFFFF">

<h1>synApps 5.4</h1>

<P>synApps is a collection of <a href=www.aps.anl.gov/epics>EPICS</a> software
(source code, EPICS databases, client scripts, display files, executables,
etc.) intended to support most of the requirements of an x-ray laboratory or
synchrotron-radiation beamline.  Because it is EPICS software, synApps is
extensible by developers and end users, to support new devices and experimental
techniques.

<P>Here's a list of the modules and directories in synApps:

<P><table border>
<tr><th>Module/directory<th>description

<tr><td><b>areaDetector</b><td>Support for area (2-D) detectors, including CCDs, pixel array
              detectors, and online imaging plates.  This module replaces the
			  ccd and pilatus modules (which are nevertheless included in this
			  version of synApps, though they will no longer be supported).
<tr><td><b>autosave</b><td>Support for saving software parameters at run time, and restoring them during the next reboot.
<tr><td><b>busy</b><td>The busy record, previously supplied by the sscan module
<tr><td><b>calc</b><td>Run-time expression evaluation
<tr><td><b>camac</b><td>Support for CAMAC hardware
<tr><td><b>ccd</b><td>Scientific CCD detectors, including Bruker, MAR, and Roper
<tr><td><b>configure</b><td>(directory) Build files, including the top-level make file
<tr><td><b>dac128V</b><td>IndustryPack DAC
<tr><td><b>delaygen</b><td>Support for delay generators
<tr><td><b>dxp</b><td>XIA's DXP digital signal processor
<tr><td><b>ebrick</b><td>Support and sample application for low-cost PC-104 and uCDIMM based IOC
<tr><td><b>ip</b><td>Support for various serial, and other message-based, devices
<tr></b><td><b>ip330</b><td>IndustryPack ADC
<tr><td><b>ipUnidig</b><td>IndustryPack digital I/O
<tr><td><b>love</b><td>Support for Love controllers
<tr><td><b>mca</b><td>Support for multichannel analyzers
<tr><td><b>modbus</b><td>Support for ModBus-protocol devices over TCP, serial RTU, and
              serial ASCII links
<tr><td><b>motor</b><td>Support for motors
<tr><td><b>optics</b><td>Support for optical tables, monochromators, slits, etc.
<tr><td><b>pilatus</b><td>Support for the Dectris pixel-array detector
<tr><td><b>quadEM</b><td>Support for an APS-developed 4-channel electrometer
<tr><td><b>sscan</b><td>Support for scans (programmed control and data acquisition).
<tr><td><b>std</b><td>Miscellaneuos EPICS software
<tr><td><b>stream</b><td>Dirk Zimoch's streamDevice, in a module-flavored wrapper
<tr><td><b>utils</b><td>(directory) Miscellaneous tools
<tr><td><b>vac</b><td>Support for vacuum controllers
<tr><td><b>vme</b><td>Support for VME hardware
<tr><td><b>xxx</b><td>Sample user-application directory
</table>

<P>See support/configure/RELEASE for a complete set of compatible module
versions.

<P>This release of synApps is compatible with EPICS release 3.14.10, and Tornado
2.2, and the following EPICS modules/versions produced and maintained by other
members of the EPICS collaboration:

<P><table border>
<tr><th>Module<th>version<th>description
<tr><td><b>allenBradley</b><td>v2-1<td>for communicating with Allen Bradley PLC's (ANL)
<tr><td><b>ipac</b><td>v2-10<td>required for IndustryPack support (ANL)
<tr><td><b>asyn</b><td>v4-10<td>required by many modules (ANL)
<tr><td><b>seq</b><td>v2-0-12<td>for SNL programs in synApps (SLAC)
<tr><td><b>stream</b><td>v2-4<td>configurable device support for message-based devices (PSI)
<tr><td><b>vxStats</b><td>v1-7-2g<td>vxWorks statistics, modified by us (SNS)
</table>

<P>Previous versions of synApps included and relied on the <b>genSub</b> module.  In
EPICS 3.14.10, a replacement for the genSub record, called the asub record, is
included in base, and synApps has been modified to use it instead of the genSub
record.

<P>For convenience, this distribution includes the module versions listed above,
in place and ready to build, with minor modifications to build files.  A few of
the modules have suffered more substantial modifications to fix problems, add
display files, etc.

<P>synApps includes software developed by the Beamline Controls & Data
Acquisition and the Accelerator Controls groups of the Advanced Photon Source
(APS); by developers in APS Collaborative Access Teams -- notably, Mark Rivers
(CARS-CAT); and by developers in the EPICS collaboration outside of the APS --
notably, those at the Swiss Light Source/Paul Scherrer Institut, the Diamond
Light Source, the National Synchrotron Light Source, the Australian Light
Source, and the Canadian Light Source.

<P>Aside from EPICS databases, SNL (State Notation Language) programs, and the
like, synApps contains the following code:

<ul>
<li><h3>Record support</h3>
<table border>
<tr><th>Record<th>Description
<tr><td><b>aCalcout</b><td>calcout record extended to handle array expressions
<tr><td><b>busy</b><td>utility record: calls recGblFwdLink only when its
	VAL field is zero, allowing CA clients, and asyn drivers to
	participate in EPICS putNotify (ca_put_callback()) operations.
<tr><td><b>dxp</b><td>XIA's DXP digital signal processor
	Set/read signal-processor parameters
<tr><td><b>epid</b><td>Extended version of the PID record, previously in EPICS base.
	Intended for implementing feedback loops
<tr><td><b>mca</b><td>support for multichannel analyzers, and some other
	array-valued detectors
<tr><td><b>motor</b><td>stepper and servo motors, "soft" motor
<tr><td><b>sCalcout</b><td>calcout record extended to handle string expressions,
	links, and values.
<tr><td><b>scaler</b><td>scaler bank
<tr><td><b>sscan</b><td>Replaces the scan record (Ned Arnold/APS) previously in EPICS
	base. This version uses a modified version of recDynLlib that supports
	dbNotify command completion.  It uses ca_put_callback to do puts, instead of
	ca_put.
<tr><td><b>scanparm</b><td>scan parameters for use with the scan record
<tr><td><b>sseq</b><td>string-sequence record.  This is a modified version of
	the seq record in base.  This version can link to/from
	either string or numeric PVs, and it can use
	dbCaPutLinkCallback to wait for completion of the
	execution started by one link before going on to the
	next.
<tr><td><b>swait</b><td>replaces the wait record previously in EPICS base.
	This version uses a modified version of recDynLlib
	that supports dbNotify command completion.  It uses
	ca_put_callback to do puts, instead of ca_put.
<tr><td><b>table</b><td>6-degree-of-freedom optical table
<tr><td><b>transform</b><td>like an array of calc records, with output links
<tr><td><b>vme</b><td>generic vme record (Mark Rivers/APS/CARS-CAT)
<tr><td><b>timestamp</b><td>(written by Stephanie Allison/SLAC) Needed by the vxStats
	module, but apparently not available in a published module.
</table>

<P><li><h3>Device/driver support in or included with synApps</h3>
<table border>
<tr><th>record<th>bus-type<th>codename<th>username
<tr><td>acalcout   <td>CONSTANT  <td>devaCalcoutSoft              <td>Soft Channel
<tr><td>ai         <td>AB_IO     <td>devAiAb1771Ife               <td>AB-1771IFE
<tr><td>ai         <td>AB_IO     <td>devAiAb1771Ife0to5V          <td>AB-1771IFE-0to5Volt
<tr><td>ai         <td>AB_IO     <td>devAiAb1771IfeMa             <td>AB-1771IFE-4to20MA
<tr><td>ai         <td>AB_IO     <td>devAiAb1771IfeSe             <td>AB-1771IFE-SE
<tr><td>ai         <td>AB_IO     <td>devAiAb1771Il                <td>AB-1771IL-Analog In
<tr><td>ai         <td>AB_IO     <td>devAiAb1771IrCopper          <td>AB-1771RTD-Copper
<tr><td>ai         <td>AB_IO     <td>devAiAb1771IrPlatinum        <td>AB-1771RTD-Platinum
<tr><td>ai         <td>AB_IO     <td>devAiAb1771Ixe               <td>AB-1771IXE-Millivolt In
<tr><td>ai         <td>AB_IO     <td>devAiAbSlcDcm                <td>AB-SLC500DCM
<tr><td>ai         <td>AB_IO     <td>devAiAbSlcDcmSigned          <td>AB-SLC500DCM-Signed
<tr><td>ai         <td>BBGPIB_IO <td>devAiAX301                   <td>PZT Bug
<tr><td>ai         <td>CONSTANT  <td>devAiTodSeconds              <td>Sec Past Epoch
<tr><td>ai         <td>GPIB_IO   <td>devAiGP307Gpib               <td>Vg307 GPIB Instrument
<tr><td>ai         <td>GPIB_IO   <td>devAiHeidAWE1024             <td>Heidenhein Encoder
<tr><td>ai         <td>GPIB_IO   <td>devAiKeithleyDMM199          <td>KeithleyDMM199
<tr><td>ai         <td>GPIB_IO   <td>devGpib                      <td>GPIB init/report
<tr><td>ai         <td>INST_IO   <td>asynAiFloat64                <td>asynFloat64
<tr><td>ai         <td>INST_IO   <td>asynAiFloat64Average         <td>asynFloat64Average
<tr><td>ai         <td>INST_IO   <td>asynAiInt32                  <td>asynInt32
<tr><td>ai         <td>INST_IO   <td>asynAiInt32Average           <td>asynInt32Average
<tr><td>ai         <td>INST_IO   <td>devAiAb1791                  <td>Allen Bradley 1791
<tr><td>ai         <td>INST_IO   <td>devAiAbDcm                   <td>Ab Dcm
<tr><td>ai         <td>INST_IO   <td>devAiClusts                  <td>VX stats clusts
<tr><td>ai         <td>INST_IO   <td>devAiHeidND261               <td>asyn ai HeidND261
<tr><td>ai         <td>INST_IO   <td>devAiMKS                     <td>HPS SensaVac 937
<tr><td>ai         <td>INST_IO   <td>devAiMPC                     <td>asyn MPC
<tr><td>ai         <td>INST_IO   <td>devAiStats                   <td>VX stats
<tr><td>ai         <td>INST_IO   <td>devAiStrParm                 <td>asyn ai stringParm
<tr><td>ai         <td>INST_IO   <td>devAiTPG261                  <td>asyn TPG261
<tr><td>ai         <td>INST_IO   <td>devAiTelevac                 <td>asyn Televac
<tr><td>ai         <td>INST_IO   <td>devInterfaceAI1              <td>InterfaceAI1
<tr><td>ai         <td>VME_IO    <td>devAiA32Vme                  <td>Generic A32 VME
<tr><td>ai         <td>VME_IO    <td>devAiAvmeMRD                 <td>devAvmeMRD
<tr><td>ai         <td>VME_IO    <td>devAiBunchClkGen             <td>APS Bunch Clock
<tr><td>ai         <td>VME_IO    <td>devAiVaroc                   <td>ESRF Varoc SSI Encoder Iface
<tr><td>ai         <td>VME_IO    <td>devIK320Ai                   <td>Heidenhain IK320
<tr><td>ai         <td>VME_IO    <td>devIK320GroupAi              <td>Heidenhain IK320 Group
<tr><td>ao         <td>AB_IO     <td>devAoAb1771Ofe               <td>AB-1771OFE
<tr><td>ao         <td>AB_IO     <td>devAoAbSlcDcm                <td>AB-SLC500DCM
<tr><td>ao         <td>BBGPIB_IO <td>devAoAX301                   <td>PZT Bug
<tr><td>ao         <td>GPIB_IO   <td>devAoHeidAWE1024             <td>Heidenhein Encoder
<tr><td>ao         <td>GPIB_IO   <td>devAoKeithleyDMM199          <td>KeithleyDMM199
<tr><td>ao         <td>INST_IO   <td>asynAoFloat64                <td>asynFloat64
<tr><td>ao         <td>INST_IO   <td>asynAoInt32                  <td>asynInt32
<tr><td>ao         <td>INST_IO   <td>devAoAb1791                  <td>Allen Bradley 1791
<tr><td>ao         <td>INST_IO   <td>devAoAbDcm                   <td>Ab Dcm
<tr><td>ao         <td>INST_IO   <td>devAoEurotherm               <td>asyn ao Eurotherm
<tr><td>ao         <td>INST_IO   <td>devAoMPC                     <td>asyn MPC
<tr><td>ao         <td>INST_IO   <td>devAoStats                   <td>VX stats
<tr><td>ao         <td>INST_IO   <td>devAoStrParm                 <td>asyn ao stringParm
<tr><td>ao         <td>INST_IO   <td>devAoTPG261                  <td>asyn TPG261
<tr><td>ao         <td>INST_IO   <td>devInterfaceAO1              <td>InterfaceAO1
<tr><td>ao         <td>VME_IO    <td>devAoA32Vme                  <td>Generic A32 VME
<tr><td>ao         <td>VME_IO    <td>devAoAvme9210                <td>AVME-9210
<tr><td>ao         <td>VME_IO    <td>devAoBunchClkGen             <td>APS Bunch Clock
<tr><td>ao         <td>VME_IO    <td>devAoVMI4116                 <td>VMIVME-4116
<tr><td>asyn       <td>INST_IO   <td>asynRecordDevice             <td>asynRecordDevice
<tr><td>bi         <td>AB_IO     <td>devBiAb                      <td>AB-Binary Input
<tr><td>bi         <td>AB_IO     <td>devBiAb16                    <td>AB-16 bit BI
<tr><td>bi         <td>AB_IO     <td>devBiAb32                    <td>AB-32 bit BI
<tr><td>bi         <td>GPIB_IO   <td>devBiGP307Gpib               <td>Vg307 GPIB Instrument
<tr><td>bi         <td>GPIB_IO   <td>devBiHeidAWE1024             <td>Heidenhein Encoder
<tr><td>bi         <td>GPIB_IO   <td>devBiKeithleyDMM199          <td>KeithleyDMM199
<tr><td>bi         <td>INST_IO   <td>asynBiInt32                  <td>asynInt32
<tr><td>bi         <td>INST_IO   <td>asynBiUInt32Digital          <td>asynUInt32Digital
<tr><td>bi         <td>INST_IO   <td>devBiAbDcm                   <td>Ab Dcm
<tr><td>bi         <td>INST_IO   <td>devBiMPC                     <td>asyn MPC
<tr><td>bi         <td>INST_IO   <td>devBiStrParm                 <td>asyn bi stringParm
<tr><td>bi         <td>INST_IO   <td>devBiTPG261                  <td>asyn TPG261
<tr><td>bi         <td>INST_IO   <td>devBiTelevac                 <td>asyn Televac
<tr><td>bi         <td>VME_IO    <td>devBiA32Vme                  <td>Generic A32 VME
<tr><td>bi         <td>VME_IO    <td>devBiAvme9440                <td>AVME9440 I
<tr><td>bi         <td>VME_IO    <td>devBiAvmeMRD                 <td>devAvmeMRD
<tr><td>bi         <td>VME_IO    <td>devBiBunchClkGen             <td>APS Bunch Clock
<tr><td>bi         <td>VME_IO    <td>devBiHP10895LaserAxis        <td>HP interferometer
<tr><td>bo         <td>AB_IO     <td>devBoAb                      <td>AB-Binary Output
<tr><td>bo         <td>AB_IO     <td>devBoAb16                    <td>AB-16 bit BO
<tr><td>bo         <td>AB_IO     <td>devBoAb32                    <td>AB-32 bit BO
<tr><td>bo         <td>BBGPIB_IO <td>devBoAX301                   <td>PZT Bug
<tr><td>bo         <td>GPIB_IO   <td>devBoGP307Gpib               <td>Vg307 GPIB Instrument
<tr><td>bo         <td>GPIB_IO   <td>devBoHeidAWE1024             <td>Heidenhein Encoder
<tr><td>bo         <td>GPIB_IO   <td>devBoKeithleyDMM199          <td>KeithleyDMM199
<tr><td>bo         <td>INST_IO   <td>asynBoInt32                  <td>asynInt32
<tr><td>bo         <td>INST_IO   <td>asynBoUInt32Digital          <td>asynUInt32Digital
<tr><td>bo         <td>INST_IO   <td>devBoAbDcm                   <td>Ab Dcm
<tr><td>bo         <td>INST_IO   <td>devBoMPC                     <td>asyn MPC
<tr><td>bo         <td>INST_IO   <td>devBoStrParm                 <td>asyn bo stringParm
<tr><td>bo         <td>INST_IO   <td>devBoTPG261                  <td>asyn TPG261
<tr><td>bo         <td>VME_IO    <td>devBoA32Vme                  <td>Generic A32 VME
<tr><td>bo         <td>VME_IO    <td>devBoAvme9440                <td>AVME9440 O
<tr><td>bo         <td>VME_IO    <td>devBoAvmeMRD                 <td>devAvmeMRD
<tr><td>bo         <td>VME_IO    <td>devBoBunchClkGen             <td>APS Bunch Clock
<tr><td>bo         <td>VME_IO    <td>devBoHP10895LaserAxis        <td>HP interferometer
<tr><td>busy       <td>CONSTANT  <td>devBusySoft                  <td>Soft Channel
<tr><td>busy       <td>INST_IO   <td>asynBusyInt32                <td>asynInt32
<tr><td>epid       <td>CONSTANT  <td>devEpidSoft                  <td>Soft Channel
<tr><td>epid       <td>INST_IO   <td>devEpidFast                  <td>Fast Epid
<tr><td>longin     <td>AB_IO     <td>devLiAbSlcDcm                <td>AB-SLC500DCM
<tr><td>longin     <td>GPIB_IO   <td>devLiHeidAWE1024             <td>Heidenhein Encoder
<tr><td>longin     <td>GPIB_IO   <td>devLiKeithleyDMM199          <td>KeithleyDMM199
<tr><td>longin     <td>INST_IO   <td>asynLiInt32                  <td>asynInt32
<tr><td>longin     <td>INST_IO   <td>asynLiUInt32Digital          <td>asynUInt32Digital
<tr><td>longin     <td>INST_IO   <td>devLiAbDcm                   <td>Ab Dcm
<tr><td>longin     <td>INST_IO   <td>devLiStrParm                 <td>asyn li stringParm
<tr><td>longin     <td>VME_IO    <td>devLiA32Vme                  <td>Generic A32 VME
<tr><td>longin     <td>VME_IO    <td>devLiAvmeMRD                 <td>devAvmeMRD
<tr><td>longin     <td>VME_IO    <td>devLiHP10895LaserAxis        <td>HP interferometer
<tr><td>longout    <td>AB_IO     <td>devLoAbSlcDcm                <td>AB-SLC500DCM
<tr><td>longout    <td>BBGPIB_IO <td>devLoAX301                   <td>PZT Bug
<tr><td>longout    <td>GPIB_IO   <td>devLoHeidAWE1024             <td>Heidenhein Encoder
<tr><td>longout    <td>GPIB_IO   <td>devLoKeithleyDMM199          <td>KeithleyDMM199
<tr><td>longout    <td>INST_IO   <td>asynLoInt32                  <td>asynInt32
<tr><td>longout    <td>INST_IO   <td>asynLoUInt32Digital          <td>asynUInt32Digital
<tr><td>longout    <td>INST_IO   <td>devLoAbDcm                   <td>Ab Dcm
<tr><td>longout    <td>INST_IO   <td>devLoStrParm                 <td>asyn lo stringParm
<tr><td>longout    <td>VME_IO    <td>devLoA32Vme                  <td>Generic A32 VME
<tr><td>longout    <td>VME_IO    <td>devLoHP10895LaserAxis        <td>HP interferometer
<tr><td>mbbi       <td>AB_IO     <td>devMbbiAb                    <td>AB-Binary Input
<tr><td>mbbi       <td>AB_IO     <td>devMbbiAb16                  <td>AB-16 bit BI
<tr><td>mbbi       <td>AB_IO     <td>devMbbiAb32                  <td>AB-32 bit BI
<tr><td>mbbi       <td>AB_IO     <td>devMbbiAbAdapterStat         <td>AB-Adapter Status
<tr><td>mbbi       <td>AB_IO     <td>devMbbiAbCardStat            <td>AB-Card Status
<tr><td>mbbi       <td>GPIB_IO   <td>devMbbiHeidAWE1024           <td>Heidenhein Encoder
<tr><td>mbbi       <td>GPIB_IO   <td>devMbbiKeithleyDMM199        <td>KeithleyDMM199
<tr><td>mbbi       <td>INST_IO   <td>asynMbbiInt32                <td>asynInt32
<tr><td>mbbi       <td>INST_IO   <td>asynMbbiUInt32Digital        <td>asynUInt32Digital
<tr><td>mbbi       <td>INST_IO   <td>devMbbiAbDcm                 <td>Ab Dcm
<tr><td>mbbi       <td>INST_IO   <td>devMbbiTPG261                <td>asyn TPG261
<tr><td>mbbi       <td>VME_IO    <td>devMbbiA32Vme                <td>Generic A32 VME
<tr><td>mbbi       <td>VME_IO    <td>devMbbiAvme9440              <td>AVME9440 I
<tr><td>mbbi       <td>VME_IO    <td>devMbbiAvmeMRD               <td>devAvmeMRD
<tr><td>mbbi       <td>VME_IO    <td>devMbbiHP10895LaserAxis      <td>HP interferometer
<tr><td>mbbiDirect <td>AB_IO     <td>devMbbiDirectAb              <td>AB-Binary Input
<tr><td>mbbiDirect <td>AB_IO     <td>devMbbiDirectAb16            <td>AB-16 bit BI
<tr><td>mbbiDirect <td>AB_IO     <td>devMbbiDirectAb32            <td>AB-32 bit BI
<tr><td>mbbiDirect <td>INST_IO   <td>asynMbbiDirectUInt32Digital  <td>asynUInt32Digital
<tr><td>mbbo       <td>AB_IO     <td>devMbboAb                    <td>AB-Binary Output
<tr><td>mbbo       <td>AB_IO     <td>devMbboAb16                  <td>AB-16 bit BO
<tr><td>mbbo       <td>AB_IO     <td>devMbboAb32                  <td>AB-32 bit BO
<tr><td>mbbo       <td>GPIB_IO   <td>devMbboHeidAWE1024           <td>Heidenhein Encoder
<tr><td>mbbo       <td>GPIB_IO   <td>devMbboKeithleyDMM199        <td>KeithleyDMM199
<tr><td>mbbo       <td>INST_IO   <td>asynMbboInt32                <td>asynInt32
<tr><td>mbbo       <td>INST_IO   <td>asynMbboUInt32Digital        <td>asynUInt32Digital
<tr><td>mbbo       <td>INST_IO   <td>devMbboAbDcm                 <td>Ab Dcm
<tr><td>mbbo       <td>INST_IO   <td>devMbboMPC                   <td>asyn MPC
<tr><td>mbbo       <td>INST_IO   <td>devMbboTPG261                <td>asyn TPG261
<tr><td>mbbo       <td>VME_IO    <td>devIK320Dir                  <td>Heidenhain IK320 Sign
<tr><td>mbbo       <td>VME_IO    <td>devIK320Funct                <td>Heidenhain IK320 Command
<tr><td>mbbo       <td>VME_IO    <td>devIK320ModeX3               <td>Heidenhain IK320 X3 Mode
<tr><td>mbbo       <td>VME_IO    <td>devMbboA32Vme                <td>Generic A32 VME
<tr><td>mbbo       <td>VME_IO    <td>devMbboAvme9440              <td>AVME9440 O
<tr><td>mbbo       <td>VME_IO    <td>devMbboHP10895LaserAxis      <td>HP interferometer
<tr><td>mbboDirect <td>AB_IO     <td>devMbboDirectAb              <td>AB-Binary Output
<tr><td>mbboDirect <td>AB_IO     <td>devMbboDirectAb16            <td>AB-16 bit BO
<tr><td>mbboDirect <td>AB_IO     <td>devMbboDirectAb32            <td>AB-32 bit BO
<tr><td>mbboDirect <td>INST_IO   <td>asynMbboDirectUInt32Digital  <td>asynUInt32Digital
<tr><td>mca        <td>CONSTANT  <td>devMCA_soft                  <td>Soft Channel
<tr><td>mca        <td>INST_IO   <td>devMcaAsyn                   <td>asynMCA
<tr><td>mca        <td>VME_IO    <td>devSTR7201                   <td>Struck STR7201 MCS
<tr><td>motor      <td>CONSTANT  <td>devMotorSoft                 <td>Soft Channel
<tr><td>motor      <td>INST_IO   <td>devMotorAsyn                 <td>asynMotor
<tr><td>motor      <td>VME_IO    <td>devE500                      <td>E500
<tr><td>motor      <td>VME_IO    <td>devESP300                    <td>ESP300
<tr><td>motor      <td>VME_IO    <td>devIM483PL                   <td>IM483PL
<tr><td>motor      <td>VME_IO    <td>devIM483SM                   <td>IM483SM
<tr><td>motor      <td>VME_IO    <td>devMAXv                      <td>OMS MAXv
<tr><td>motor      <td>VME_IO    <td>devMCB4B                     <td>ACS MCB-4B
<tr><td>motor      <td>VME_IO    <td>devMCDC2805                  <td>MCDC2805
<tr><td>motor      <td>VME_IO    <td>devMDrive                    <td>MDrive
<tr><td>motor      <td>VME_IO    <td>devMM3000                    <td>MM3000
<tr><td>motor      <td>VME_IO    <td>devMM4000                    <td>MM4000
<tr><td>motor      <td>VME_IO    <td>devMVP2001                   <td>MVP2001
<tr><td>motor      <td>VME_IO    <td>devMicos                     <td>Micos MoCo
<tr><td>motor      <td>VME_IO    <td>devMotorSim                  <td>Motor Simulation
<tr><td>motor      <td>VME_IO    <td>devOMS                       <td>OMS VME8/44
<tr><td>motor      <td>VME_IO    <td>devOms58                     <td>OMS VME58
<tr><td>motor      <td>VME_IO    <td>devOmsPC68                   <td>OMS PC68/78
<tr><td>motor      <td>VME_IO    <td>devPC6K                      <td>PC6K
<tr><td>motor      <td>VME_IO    <td>devPIC630                    <td>PI C630
<tr><td>motor      <td>VME_IO    <td>devPIC662                    <td>PIC662
<tr><td>motor      <td>VME_IO    <td>devPIC844                    <td>PIC844
<tr><td>motor      <td>VME_IO    <td>devPIC848                    <td>PIC848
<tr><td>motor      <td>VME_IO    <td>devPIC862                    <td>PIC862
<tr><td>motor      <td>VME_IO    <td>devPIE516                    <td>PIE516
<tr><td>motor      <td>VME_IO    <td>devPIE710                    <td>PIE710
<tr><td>motor      <td>VME_IO    <td>devPIE816                    <td>PIE816
<tr><td>motor      <td>VME_IO    <td>devPM304                     <td>Mclennan PM304
<tr><td>motor      <td>VME_IO    <td>devPM500                     <td>PM500
<tr><td>motor      <td>VME_IO    <td>devPMNC87xx                  <td>PMNC87xx
<tr><td>motor      <td>VME_IO    <td>devPmac                      <td>PMAC
<tr><td>scalcout   <td>CONSTANT  <td>devsCalcoutSoft              <td>Soft Channel
<tr><td>scaler     <td>INST_IO   <td>devScalerAsyn                <td>Asyn Scaler
<tr><td>scaler     <td>VME_IO    <td>devScaler                    <td>Joerger VSC8/16
<tr><td>scaler     <td>VME_IO    <td>devScalerCamac               <td>CAMAC scaler
<tr><td>scaler     <td>VME_IO    <td>devScalerSTR7201             <td>Struck STR7201 Scaler
<tr><td>scaler     <td>VME_IO    <td>devScaler_VS                 <td>Joerger VS
<tr><td>stringin   <td>CONSTANT  <td>devSiTodString               <td>Time of Day
<tr><td>stringin   <td>GPIB_IO   <td>devSiGP307Gpib               <td>Vg307 GPIB Instrument
<tr><td>stringin   <td>GPIB_IO   <td>devSiHeidAWE1024             <td>Heidenhein Encoder
<tr><td>stringin   <td>GPIB_IO   <td>devSiKeithleyDMM199          <td>KeithleyDMM199
<tr><td>stringin   <td>INST_IO   <td>asynSiOctetCmdResponse       <td>asynOctetCmdResponse
<tr><td>stringin   <td>INST_IO   <td>asynSiOctetRead              <td>asynOctetRead
<tr><td>stringin   <td>INST_IO   <td>asynSiOctetWriteRead         <td>asynOctetWriteRead
<tr><td>stringin   <td>INST_IO   <td>devSiMPC                     <td>asyn MPC
<tr><td>stringin   <td>INST_IO   <td>devSiSeq                     <td>Sequencer Internals
<tr><td>stringin   <td>INST_IO   <td>devSiStrParm                 <td>asyn si stringParm
<tr><td>stringin   <td>INST_IO   <td>devSiTPG261                  <td>asyn TPG261
<tr><td>stringin   <td>INST_IO   <td>devStringinStats             <td>VX stats
<tr><td>stringout  <td>GPIB_IO   <td>devSoHeidAWE1024             <td>Heidenhein Encoder
<tr><td>stringout  <td>GPIB_IO   <td>devSoKeithleyDMM199          <td>KeithleyDMM199
<tr><td>stringout  <td>INST_IO   <td>asynSoOctetWrite             <td>asynOctetWrite
<tr><td>stringout  <td>INST_IO   <td>devSoEurotherm               <td>asyn so Eurotherm
<tr><td>stringout  <td>INST_IO   <td>devSoMPC                     <td>asyn MPC
<tr><td>stringout  <td>INST_IO   <td>devSoStrParm                 <td>asyn so stringParm
<tr><td>stringout  <td>VME_IO    <td>devIK320Parm                 <td>Heidenhain IK320 Parameter
<tr><td>swait      <td>CONSTANT  <td>devSWaitIoEvent              <td>Soft Channel
<tr><td>waveform   <td>INST_IO   <td>asynFloat32ArrayWfIn         <td>asynFloat32ArrayIn
<tr><td>waveform   <td>INST_IO   <td>asynFloat32ArrayWfOut        <td>asynFloat32ArrayOut
<tr><td>waveform   <td>INST_IO   <td>asynFloat64ArrayWfIn         <td>asynFloat64ArrayIn
<tr><td>waveform   <td>INST_IO   <td>asynFloat64ArrayWfOut        <td>asynFloat64ArrayOut
<tr><td>waveform   <td>INST_IO   <td>asynInt16ArrayWfIn           <td>asynInt16ArrayIn
<tr><td>waveform   <td>INST_IO   <td>asynInt16ArrayWfOut          <td>asynInt16ArrayOut
<tr><td>waveform   <td>INST_IO   <td>asynInt32ArrayWfIn           <td>asynInt32ArrayIn
<tr><td>waveform   <td>INST_IO   <td>asynInt32ArrayWfOut          <td>asynInt32ArrayOut
<tr><td>waveform   <td>INST_IO   <td>asynInt8ArrayWfIn            <td>asynInt8ArrayIn
<tr><td>waveform   <td>INST_IO   <td>asynInt8ArrayWfOut           <td>asynInt8ArrayOut
<tr><td>waveform   <td>INST_IO   <td>asynWfOctetCmdResponse       <td>asynOctetCmdResponse
<tr><td>waveform   <td>INST_IO   <td>asynWfOctetRead              <td>asynOctetRead
<tr><td>waveform   <td>INST_IO   <td>asynWfOctetWrite             <td>asynOctetWrite
<tr><td>waveform   <td>INST_IO   <td>asynWfOctetWriteRead         <td>asynOctetWriteRead
<tr><td>waveform   <td>VME_IO    <td>devWfBunchClkGen             <td>APS Bunch Clock
</table>

<P><li><h3>Miscellaneous C code</h3>
<dl>
<dt>aCalcPostfix, aCalcPerform
	sCalcPostfix, sCalcPerform
	<dd>Support for run-time expression evaluation
<dt>recDynLink
	<dd>Backward compatible extension of the dynamic-link software
		previously in EPICS base.  (New code should probably use
		dbCaPutlinkCallback(), instead of recDynLink.)
<dt>save_restore, dbrestore
	<dd>Automatic parameter save and boot-time restore.
<dt>saveData
	<dd>Saves scan data to files on an NFS-mounted disk (vxWorks), or to
	a local disk (other operating systems).
</dl>

<P><li><h3>Documentation</h3>

	<P>In addition to this top-level documentation, synApps modules have their
	own documentation directories, and the xxx module contains examples of
	how most of the software is loaded and run. Some modules have their own
	example iocBoot directories.


<P><li><h3>Miscellaneous</h3>

	<P>The synApps support/utils directory contains a variety of scripts,
	programs, etc., that some have found useful.
</ul>

<hr>
<h2>How to deploy synApps</h2>

<P>Although synApps is distributed as a single 'support' directory, it's
normally deployed as a two-part system: a 'support' directory, and one or more
'user' directories.  The support directory can be installed on a read-only file
system, along with EPICS base and other modules, and used from there by user
directories, each of which begins as a copy (or a collection of copies) of the
module 'support/xxx', and is customized/extended to suit a particular
application and set of hardware.

<P>I'm not being very precise about what is meant by a user directory, because
there are a number of reasonable variations.  At the simplest, a single copy of
the <b>xxx</b> module, which supports a single IOC, is a user directory.  If several
IOC's cooperate to serve a single application (such as a synchrotron beamline),
one might make several independent copies of the xxx directory, or one might
extend the xxx copy to contain multiple xxxApp directories, and multiple
iocBoot/iocxxx directories.  At APS, we have several top-level user directories,
each of which contains a number of copies of xxx, most of which, in turn,
contain multiple xxxApp and iocBoot/iocxxx directories.

<blockquote><i>If you haven't run into the term 'IOC' yet, it stands for
Input/Output Controller.  Initially, this was a VME crate with a processor
running EPICS under the VxWorks operating system, but beginning with EPICS 3.14,
an IOC can also be a set of tasks on a workstation running Linux, Windows,
Cygwin, Solaris, RTEMS, Mac OS, and, no doubt, other operating systems.</i>
</blockquote>

<P>Here's what a complete installation might look like (much detail omitted)
with all the files you will have to edit before you can build or boot an IOC.
In the following, 'WIN32' means native Windows, as distinguished from Windows
used via the Cygwin unix-like environment:

<P><h4> The support directory</h4>
<pre>
synApps_5_4/support/
    Makefile                            <-- EDIT to build
    Makefile.win32-x86                  <-- EDIT to build for WIN32
    all_adl/
    allenBradley/
    areaDetector/
    asyn/
    busy/
    calc/
    camac/
    ccd/
    configure/
        CONFIG_SITE                     <-- EDIT to build
        RELEASE                         <-- EDIT to build
        RELEASE.win32-x86               <-- EDIT to build for WIN32
        ...
    dac128V/
    delaygen/
    documentation/
    dxp/
    ebrick/
    ip/
    ip330/
    ipUnidig/
    ipac/
        drvIpac/drvIpac.dbd             <-- EDIT to build
    love/
    mca/
    modbus/
    motor/
        motorApp/
            Makefile                    <-- EDIT to build
    optics/
    pilatus/
    quadEM/
    seq/
    sscan/
    std/
    stream/
    utils/
    vac/
    vme/
    vxStats/
    xxx/

</pre>
<P><h4> The user-directory tree</h4>
<pre>
synApps_5_4/ioc/
    1bm/
        Makefile
        bin/
        configure/
            RELEASE                     <-- EDIT to build
            RELEASE.win32-x86           <-- EDIT to build for WIN32
        dbd/
        iocBoot/
            Makefile
            nfsCommands
            ioc1bma/
                Makefile
                camac.cmd
                canberra_1.cmd
                canberra_13.cmd
                canberra_3.cmd
                dac128V.cmd
                dxp_16.cmd
                industryPack.cmd
                ip330.cmd
                ipUnidig.cmd
                quadEM.cmd
                save_restore.cmd
                serial.cmd
                vme.cmd
                st.cmd
                basic_motor.substitutions
                canberra_13.substitutions
                canberra_3.substitutions
                dac128V.substitutions
                dxp_16.substitutions
                ip330Scan.substitutions
                ipUnidig.substitutions
                motor.substitutions
                picMot.substitutions
                pid_fast.substitutions
                pid_slow.substitutions
                quadEM_pid.substitutions
                scanParms.substitutions
                vxStats.substitutions
                auto_positions.req 
                auto_settings.req
                autosave/
                cdCommands or envPaths
                saveData.req 
            ioc1bmb/
            ioc1bmc/
            ioc1bmd/
                &lt;much like ioc1bma&gt;
        release.pl
        setup_epics_common
        start_epics_1bma
        start_epics_1bmb
        start_epics_1bmc
        start_epics_1bmd
        1bmaApp/
        1bmbApp/
        1bmcApp/
        1bmdApp/

    1id/
    2bm/
    2id/
	...
        &lt;much like 1bm&gt;
</pre>

<P>As shown above, the following files can or must be edited to modify the way
the synApps support directory is built:

<blockquote>
<dl>
<dt><code>support/Makefile</code>
    <dd>comment out any modules you don't want to build

<P><dt><code>support/configure/RELEASE</code>

	<dd>edit the definitions of EPICS_BASE and SUPPORT with the correct paths to
	these directories on your system.  Note that you should run <code>make
	release</code> in the support directory after modifying this file, to
	propagate the changes down to the modules named in
	<code>support/Makefile</code>.

<P><dt><code>support/configure/CONFIG_SITE</code>
	<dd>Edit to set the following variables, which control what will be built:
	The supported values for these variables are <code>YES</code> and
	<code>NO</code>.
	<dl>
	<dt><code>LINUX_USB_INSTALLED</code>
		<dd>This controls the build of the <b>dxp</b> module.  If usb is not installed
		for developers, then parts of dxp/dxpApp/handelSrc will not be built,
		and the example application executable, dxpApp, will not be built, so
		dxp/iocBoot cannot be used.

	<dt><code>LINUX_NET_INSTALLED</code>
		<dd>This controls the build of the <b>mca</b> module, specifically, support for
		the Canberra AIM hardware.

	<dt><code>LINUX_TIFF_INSTALLED</code>
		<dd>This controls the build of the areaDetector module, and is understood
		to indicate whether libtiff.a, libjpeg.a, and libz.a are all
		installed.  If they are not installed, areaDetector will not build
		the following directories that requires them: prosilicaSrc, pilatusSrc,
		and marCCDSrc.
	</dl>

<dt><code>ipac/&lt;version&gt;/drvIpac/drvIpac.dbd</code>
	<dd>uncomment registrar() commands for IndustryPack carriers you plan to use.

<P><dt><code>motor/&lt;version&gt;/motorApp/Makefile</code>
	<dd>comment or uncomment to select the motor support you want to build.
</dl>
</blockquote>


<P>The following files must be edited before building a user directory:

<blockquote>
<dl>
<dt><code>ioc/&lt;appname&gt;/configure/RELEASE</code><br>
<code>ioc/&lt;appname&gt;/configure/RELEASE.win32-x86</code> (WIN32 only)
	<dd>edit the definition of SUPPORT with the correct path to the support directory
</dl>
</blockquote>

<P>The association between a user directory, and the support directory on which
it depends, is made entirely by the file, <code>configure/RELEASE</code>, in the
user directory.  Typically, this file simply includes the
<code>configure/RELEASE</code> file from the support directory, but it may
differ: it may specify EPICS modules not included in synApps, for example.  Or,
if the support directory contains more than one built version of a module (the
original and a bug fix, for example) the user directory can choose which
version it will use.

<blockquote><i>
Note, however, that the modules in synApps are not independent of
each other.  Many of the modules depend on the <b>asyn</b> module, for example,
and there are many other dependencies, both direct and implied. (If module
<b>a</b> depends on module <b>b</b>, and module <b>b</b> depends on module
<b>c</b>, then <b>a</b> also depends on <b>c</b>, and it must specify the
same version of <b>c</b> that <b>b</b> specifies.)  The complete set of modules
selected by a user directory must be self consistent, and the EPICS build will
ensure this, unless you tell it not to.
</i></blockquote>

<hr>
<h2> How to build synApps</h2>
<ol>
<h3><li>System configuration</h3>

<P>Before building synApps, you should ensure that your system has the
libraries, header files, etc. required to build the modules you want
to build.  Here's a list of the operating-system dependencies we've
documented so far.

<blockquote><i>

Please help: new users are particularly well placed to help us complete this
list.  Long-time developers typically have lots of things correctly configured
that they don't even remember configuring.

</i></blockquote>

<ul>
<li>Linux:
<dl>
<dt>libtiff.a,libjpeg.a, libz.a, and associated header files<dd>needed for the
<b>areaDetector</b> module
<dt>libusb.a, and associated header files<dd>needed for the <b>dxp</b> module
</dl>

<li>Cygwin:
<P>Cygwin is configured from a menu of choices organized by function.  You will
need the following components from the following menu headings:
	<ul>
		<li>base
		<ul>
			<li>All default components
		</ul>
		<li>devel
		<ul> 
			<li>gcc-core
			<li>gcc-g++
			<li>libncurses-devel
			<li>make
			<li>readline
		</ul>
		<li>interpreters
		<ul>
			<li>perl
		</ul>
		<li>libs
		<ul>
			<li>ncurses
		<li>sunrpc
		</ul>
		<li>misc
		<ul>
			<li>DLPORTIO needed for the <b>dxp</b> module
		</ul>
	</ul>

<P><li>Windows:
<dl>
<dt>DLPORTIO<dd>needed for the <b>dxp</b> module
</dl>

</ul>

<P><h3><li>Building and configuring the support directory</h3>


<P>If you have a built copy of EPICS base 3.14.10 or later, then building the
synApps support directory should be very simple:

<ol>
<li>Edit <code>support/Makefile</code>, <code>support/configure/RELEASE</code>,
   and <code>support/configure/CONFIG_SITE</code>, as noted above.

<li>Edit <code>ipac/&lt;version&gt;/drvIpac/drvIpac.dbd</code>, and
   <code>motor/&lt;version&gt;/motorApp/Makefile</code>, as noted above

<li>Set the environment variable <code>EPICS_HOST_ARCH</code> to the architecture (and
   compiler, if there is a choice) on which you are building. I used
   <code>solaris-sparc</code>, <code>linux-x86</code>, and <code>cygwin-x86</code>.

<li>In support, run <code>make release</code>.

<li>In support, run <code>make</code>.  (You should be able to use <code>make -j</code> to
build synApps much more quickly than it has previously built.)
</ol>

<P>You should use the same GNU Make executable that was used to build EPICS
base.  You may need <code>$(EPICS_BASE)/bin/&lt;arch&gt;</code> in your path,
and you may need <code>$(EPICS_BASE)/lib/&lt;arch&gt;</code> in
<code>LD_LIBRARY_PATH</code>.

<P>When executed in the support directory, <code>make release</code> will go to all
of the modules <code>support/Makefile</code> knows about and edit the
<code>configure/RELEASE</code>
files in those modules so that they all build from the same versions of EPICS
base and other known modules.

<P>Typically, make will not succeed the first time, because you will not have
all of the required system support.  If you find that you cannot build some
synApps module, you should comment it out of both <code>support/Makefile</code>,
and <code>support/configure/RELEASE</code> (<code>RELEASE.win32-x86</code> for WIN32 builds).

<P><h3><li>Building and configuring a user directory</h3>

<P>Once synApps' support directory has built without errors, the <b>xxx</b>
module will have been configured (<code>xxx/configure/RELEASE</code> will have
correct, absolute paths to base and support) and built, so you can use it as
an example -- or, better, a template -- for constructing user directories to
support your IOCs.  To make a template of xxx, clean and uninstall it, and tar a
copy of the directory.  To use the template, untar it, cd to its top-level
directory and run <code>utils/changePrefix</code> to change the PV-name prefix
from xxx to whatever you want.  (Note you must have support/utils in your
command path, or you could copy <code>utils/changePrefix</code> and
<code>utils/doSed</code> to a directory that is in your command path.  Note that
<code>changePrefix</code> is synApps-version specific.)

<P>Here's what I do:
<pre>
	# Do once when synApps is built:
	cd $(SYNAPPS)/support/xxx
	setenv EPICS_HOST_ARCH &lt;host architecture&gt;
	gnumake clean uninstall
	(repeat as needed for any other architectures)
	tar cvf ../xxx.tar *

	# Do whenever a new user directory ('1bm', in this example) is needed:
	cd $(SYNAPPS)/ioc
	mkdir 1bm
	cd 1bm
	tar xf $(SYNAPPS)/support/xxx.tar
	changePrefix xxx 1bma
	mv iocBoot/iocvxWorks iocBoot/ioc1bma
	edit iocBoot/ioc1bma/Makefile to specify the IOC processor type
	gnumake
</pre>

<P>To put a second application, 1bmb, into 1bm, I run the following commands:
<pre>
	cd $(SYNAPPS)/ioc
	mkdir temp
	cd temp
	tar xf $(SYNAPPS)/support/xxx.tar
	changePrefix xxx 1bmb
	mv iocBoot/iocvxWorks iocBoot/ioc1bmb
	edit iocBoot/ioc1bmb/Makefile to specify the ioc processor type
	cd $(SYNAPPS)/ioc
	mv temp/1bmbApp/start_epics_1bmb 1bm
	mv temp/1bmbApp 1bm
	mv temp/iocBoot/ioc1bmb 1bm/iocBoot
	rm -rf temp
	cd 1bm
	gnumake
</pre>

<P>Edit the files above to agree with your hardware, to load the databases you
want, etc., set up the IOC processor's parameters to load from the software
just configured, and boot the crate.  If you don't know how to do this, read
on.
</ol>

<hr>
<h2>How to make synApps work</h2>
<ol>
<h3><li>Setting up the IOC (vxWorks)</h3>

<P>Ensure that <code>$(EPICS_BASE)/bin/&lt;arch&gt;/caRepeater</code> gets run
when your
workstation boots.  If you have no way of doing this, you can run it manually
or put the command in your .login file.

<P>Setup your host system to work with the EPICS processor.  See the <i>VxWorks
Programmer's Guide</i> if you have a copy.  Here's what we do (on a Sun
workstation):
<ul>
<li>Add a user named <vx_username> with the password <vx_password>.
    The user has nothing in its home directory, and very few priviledges.

<li>Connect an ethernet cable to the processor.

<li>Setup the workstation to use a serial port at 9600 baud.
    Connect a serial cable from the workstation to the VME
    processor's "Console" port.

<li>Start up an "xterm" on the workstation and type
    <pre>cu -lttya</pre>
    <P>(On some workstations we must type "<code>cu -lcua/a</code>".)
    This gets the xterm communicating with the crate processor.

<li>Turn the crate on.  The crate processor says "Press any key to
    stop auto-boot..." and a number counting down from 7.  Pressing
    a key gets the prompt "[VxWorks Boot]:"

<li>Type "p" to see the current boot parameters,  type "c" to
    change them.  Here are sample boot parameters 
<pre>
    boot device          : dc 
    processor number     : 0 
    host name            : <server> 
    file name            : /usr/local/vxWorks/T222/mv2700-asd1
    inet on ethernet (e) : xxx.xxx.xxx.xxx:fffffe00 
    inet on backplane (b): 
    host inet (h)        : xxx.xxx.xxx.xxx
    gateway inet (g)     : 
    user (u)             : <vx_username> 
    ftp password (pw) (blank = use rsh): <vx_password>  
    flags (f)            : 0x0
    target name (tn)     : iocxxx
    startup script (s)   : /home/server/USER/epics/xxx/iocBoot/iocxxx/st.cmd
    other (o)            : 
</pre>
</ul>

<P>See <code>support/xxx/iocBoot/ioc*/bootParms</code> for other processor
types.  If your VME processor has mount access to an 'APSshare' NFS file
server, you can specify the 'file name', above, as
"/APSshare/vw/T222/mv2700-asd1".


<P><h3><li>Display files</h3>

<P>synApps includes hundreds of display files intended for use with the
EPICS display manager, MEDM.  Other EPICS display managers exist, and I once did
a mass automated translation of MEDM display files to the EDL display manager's
file format, using software developed by others.  This translation was only
partially satisfactory, but we don't have the resources to do the job better or
more generically.  In this documentation, I'll limit attention to MEDM display
files.



<P><h3><li>Fitting synApps to a particular set of hardware</h3>


<P>This happens in the user directory.  Generally, you must tell "EPICS" what
hardware is in your crate, and what addresses, interrupt vectors, etc. you have
set your hardware to use.  (See support/xxx/documentation/vme_address.html for a
list of suggested values.)  You also must specify which motors any slit,
table, monochromator, etc., control software is to use.  If you use serial or
GPIB, you must match port names to hardware devices, set serial-port parameters,
and specify GPIB addresses.  For any IndustryPack modules, you must specify the
IP carrier and slot into which you've loaded those modules.

<P>In a complete job of fitting synApps to an IOC's hardware, all of the
following files will be touched:
<dl>
<dt><code>xxx/iocBoot/ioc*/st.cmd</code>
<dd>This is the ioc's startup script, and it loads the other .cmd files 

<P><dt><code>xxx/iocBoot/ioc*/*.cmd</code><br>
    <code>xxx/iocBoot/ioc*/*.substitutions</code>
<dd>Other command files that may or may not be invoked by st.cmd
	
<P><dt><code>xxx/iocBoot/ioc*/auto_positions.req</code><br>
    <code>xxx/iocBoot/ioc*/auto_settings.req</code>
<dd>specifies PV's to be saved/restored automatically

<P><dt><code>xxx/iocBoot/ioc*/saveData.req</code>
<dd>identifies PV's used by the saveData software,  sscan records to be
	monitored for data, and PV's whose values are to be included in all
	scan-data files.

<P><dt><code>xxx/iocBoot/ioc*/bootParms</code>
<dd>a copy of the boot parameters (in case the IOC processor
        crashes in a way that erases nonvolatile memory)
</dl>

<P><ul>
<li><code>xxx/iocBoot/ioc*/st.cmd</code>

<P>This is the file run by the IOC at boot time.  It loads an executable built in
the IOC directory (e.g., <code>xxx</code>, or <code>xxx.munch</code>), sets parameters to configure that
software, makes calls to that software to configure it for a particular set of
hardware, and loads databases from synApps modules.  Mostly, it sources other
.cmd files that do these same things.

<P>This file, and the files it sources, are probably worth studying.  They are
reasonably well commented, and contain <code>dbLoadRecords()</code> commands for most of
the EPICS databases in synApps. 

<P><li>Motors

<P>To load more motors, add lines to the file
<code>xxx/iocBoot/ioc*/motor.substitutions</code>. For motors controlled by a
VME board, edit <code>vme.cmd</code> to specify the hardware address, etc.  For
motors controlled through a serial connection, edit <code>serial.cmd</code>.

<P>If you want the new motors to work with the 'AllStop' button
(<code>xxx:allstop.VAL</code>
-- see the top-level MEDM display <code>xxx.adl</code>), load the database
<code>$(MOTOR)/db/motorUtil.db</code>, and run the command
<code>motorUtilInit("xxx:")</code>.

<P>If you want the IOC automatically to save positions and settings of the new
motors, and restore them when the crate reboots, add lines to the files
<code>xxx/iocBoot/ioc*/auto_settings.req</code> and
<code>xxx/iocBoot/ioc*/auto_positions.req</code>.

<P><li>Slits

<P>To use a pair of motors to control a slit, search for <code>2slit.db</code>
in <code>xxx/iocBoot/ioc*/st.cmd</code>, and edit the
<code>dbLoadRecords()</code> command you'll find there.  The example in
<code>st.cmd</code> loads two copies of <code>2slit.db</code> intended for use
as the horizontal and vertical members of a four-jaw slit.  The MEDM displays
<code>2slit*.adl</code> and <code>4slit*.adl</code> are involved in these
applications.

<P>The slit database makes the following assumptions about the two motors
attached to the individual slit leaves:
<ul>
<li>Both of them have the same engineering units.
<li>Their .VAL fields are in the same coordinate system.  I.e., if the slit is
closed, both motors have the same value.
<li>The APS standard beamline coordinate system is used.  Positive Z is the beam
direction; positive Y is upward; positive X is outward from the storage ring.
So then, if I open a slit, one motor's .VAL field increases and the other's
decreases.
</ul>

<P>The <code>2slit.db</code> database allows users to move either the slit
virtual motors or the actual motors, and it keeps all the readback values
current regardless of how the actual motors got moved or recalibrated. But it
does not automatically reset the slit *drive* values when the actual motors are
used.  This must be done manually, using the "SYNC" button on the
<code>2slit.adl</code> display.  Pressing this button causes the database to
read the actual motor drive values and set the slit-drive values accordingly.

<P>To recalibrate slit positions, press the "Set" button, type in the current slit
position as you want it to be called, and press the "Use" button.  This
procedure uses the "Set" buttons of both motors the slit software talks to, and
the user/dial offsets of those motors actually implement the recalibration. 

<P>There is a new, experimental slit database in synApps which uses soft motor
records as the user/client interface.  This allows clients that know how to
control a motor also to control a slit, with some limitations.  We hope to use
soft motor records in front of other positioners (e.g. monochromators, optical
tables, insertion devices, and DAC channels) in the future.

<P><li>Optical tables

<P>Optical tables are controlled by a custom EPICS record (the "table" record),
used in the database <code>table.db</code> and controlled via MEDM displays
<code>table*.adl</code>.

<P>Table virtual motors behave in much the same way as do slit virtual motors. 
However, the table software does not use user/dial offsets in the underlying
motor to implement recalibration (it can't, since it works through a nonlinear
transform).  Instead, the table maintains its own offsets for all of the six
coordinated motions it implements. Pressing the "Set" button causes new table
positions to modify the offsets instead of moving the table (which is exactly
the way motor and slit calibration works).  In addition to a "Sync" button,
which reads motor positions and calculates the table positions from them, the
table display has an "Init" button, which zeros all offsets before doing a
"sync" operation.  It also has a "Zero" button, which manipulates all the table
offsets to make the current table positions zero without moving or
recalibrating any motors.

<P><li>Monochromators

<P>Several varieties of crystal monochromators are supported in synApps: two
constant-offset "channel-cut" monochromators, a high-resolution double-crystal
monochromator, and a spherical-grating monochromator. Most are supported by
databases paired with State Notation Language (SNL) programs, and several MEDM
displays.  The EPICS databases <code>kohzuSeq.db</code>, SNL program
<code>kohzuCtl.st</code>, and MEDM displays <code>kohzu*.adl</code> (also
<code>kohzu*.gif</code>) are involved in control of two varieties of
high-heat-load monochromators.  The EPICS database <code>hrSeq.db</code>, SNL
program <code>hrCtl.st</code>, and MEDM displays <code>hSeq*.adl</code> are
involved in control of the high-resolution double-crystal monochromator.  The
spherical grating monochromator is supported by the database <code>SGM.db</code>
and the displays <code>SGM*.adl</code>.

<P><li>Filters
<P>The APS standard user filters combine several motors and solenoids to control
the placement of filter material in the beam path.  The databases
<code>filterMotor.db</code> and <code>filterLock.db</code>, and the MEDM displays <code>*filter*.adl</code> are
involved in this application.

<P><li>Basic run-time programming

<P>Impromptu coordinated motions and other bits of run-time programming are
handled by what we call a "userCalc" (actually just a swait record with a nice
MEDM interface) or a "userTransform" (actually just a transform record with a
nice MEDM interface).  We normally load sets of these and other records into
each EPICS processor, specifically for end-user programming.  Users type in
expressions to be evaluated, and link inputs and outputs, as needed, to glue
existing objects together to do what they want done at the moment.  Here are
some examples of the tasks that have been accomplished with userCalcs and
userTransforms:

<ul>
<li>turn off hardware feedback control of a monochromator crystal when beam drops
below a user-specified level.  The userCalc monitored the EPICS PV that
contains the value of the positron beam-current, and drove a DAC channel (used
as a digital i/o bit) that enabled hardware feedback.

<li>support the ubiquitous theta/two-theta coordination by slaving the two-theta
motor's .VAL field to the theta motor's .VAL field.

<li>talk to a motor through a nonlinear transformation, e.g.,
energy-to-Bragg-angle.

<li>close slow feedback loops -- e.g., to adjust a monochromator crystal to
suppress third-order diffraction through the high-heat-load monochromator.

<li>move multichannel-analyzer regions of interest automatically as the incident
beam energy changes.

<li>save and automatically subtract shutter-closed offsets from scaler data.
</ul>

<P><li>string-expression support

<P>Run-time programming involving strings and/or numbers can be done with
userStringCalcs, which resemble userCalcs closely, but differ in significant
details.  A package containing two stringCalcs and an 'asyn' record (called a
"deviceCmdReply") is also available for run-time programming of simple support
for serial and other message-based devices.

<P><li>array-expression support

<P>Run-time programming involving arrays and/or numbers can be done with
userArrayCalcs, which resemble userCalcs closely, but differ in significant
details.

<P><li>scan support

<P>Scans of up to five dimensions are supported by the
<code>standardScans.db</code> database.  Scan data is written to disk by the
saveData program, whose user interface is contained in
<code>saveData.db</code>.  The number of data points per scan dimension is
specified when <code>standardScans.db</code> is loaded, and is limited to 2000,
unless the environment variable <code>EPICS_CA_MAX_ARRAY_BYTES</code> is
specified.

<P>Note that loading <code>saveData.db</code> does not automatically cause scan data to be
written to disk.  You must also call the function <code>saveData_Init()</code>, specifying a
scan-configuration file (<code>saveData.req</code>) which tells saveData which sscan records
to monitor.

<P>Also note that initializing saveData is an all-or-nothing choice.  If you
initialize saveData, then <i>all</i> scans performed by sscan records named in
the configuration file will be written to disk.  If saveData cannot write a
file, it will prevent the next scan from completing. (Scans performed by sscan
records that are <i>not</i> named in <code>saveData.req</code> are completely outside of this
restriction.  The data they accumulate is not written to disk by saveData, so
saveData is not involved in their operation.)

<P><li>sequence support

<P>Run-time programming of sequences is possible using the sseq record and related
MEDM displays <code>yySseq.adl</code>

<P><li>multiple-step measurement

<P>Up to four measurement steps involving positioners, detectors, and end
calculations (e.g., to support dichroism experiments) can be done with the
<code>4step.db</code> database and the related MEDM display, <code>4step.adl</code>. The entire
measurement sequence can be involved in a scan by treating the 4step database
as you would treat the scaler or mca software.
</ul>

<P><h3><li>Running synApps</h3>

<ol>
<P><li>Boot parameters

<P>See <code>xxx/iocBoot/ioc*/bootParms</code> for sample boot parameters.

<P><li>MEDM

<P>See the MEDM Operator's Manual for detailed information on the special needs of
this X11/Motif program.  I'll assume those needs have been met.

<P>Edit the file <code>xxx/start_epics_xxx</code> to so it sets the environment
 variable
<code>EPICS_APP</code> to the directory that contains <code>xxxApp</code>.  If you plan to run MEDM on a
workstation that isn't on the same subnet as the IOC's, you'll need to
uncomment and edit the definition of the environment variable
<code>EPICS_CA_ADDR_LIST</code>.  In principle, you should be able to name only the
broadcast address for the subnet that contains the IOC's, but if this doesn't
work, you can put in the IP addresses of all the IOC's you want to connect
with, separated by spaces, as follows:

	<pre>setenv EPICS_CA_ADDR_LIST "164.54.53.126 164.54.53.127"</pre>

<P>If you want to use arrays larger than 16000 bytes (e.g., MCA spectra of more
than 4000 channels, or scans of more than 2000 data points), you must set the
environment variable <code>EPICS_CA_MAX_ARRAY_BYTES</code>, in *both* the IOC and
workstation, to the size of the largest array you plan to send over the
network, plus the size of the extra data channel access might be asked to
include with the array.  On a Unix system, for example, you might say

	<pre>setenv EPICS_CA_MAX_ARRAY_BYTES 64008</pre>

in the IOC's st.cmd file, you'd say

	putenv "EPICS_CA_MAX_ARRAY_BYTES=64008"

<P>To bring up the top-level MEDM display for synApps software, cd to xxx and type
"start_epics_xxx" (e.g., start_epics_1bma).  This script locates the
directories that might have MEDM-display files and includes them in the
environment variable EPICS_DISPLAY_PATH, cd's to xxxApp/op/adl, and runs MEDM
with the default top-level display file.

<P><li>autosave/restore

<P>You must give the crate write permission to xxx/iocBoot/ioc*/autosave so it can
write the files auto_positions.sav and auto_settings.sav there.  It's also
helpful to set the autosave directory's 'group' bit so that files the crate
writes will be owned by the owner of the directory instead of by
<vxworks_user>.  Normally, I do this:

    chmod a+w,g+s autosave

<P>To modify the list of PV's that are saved and restored, edit the files

   xxx/iocBoot/ioc*/auto_settings.req and
   xxx/iocBoot/ioc*/auto_positions.req

<P>The autosave software is started by the lines "create_monitor_set(..." in
xxx/iocBoot/ioc*/st.cmd.  The restore happens during iocInit as a result of
function calls inserted into initHooks.o, which is loaded by
xxx/iocBoot/ioc*/st.cmd.


<P><li>saveData

<P>saveData is a CA client that monitors sscan records and saves scan data to
files on as NFS-mounted disk.  The software is configured with the file
xxx/iocBoot/ioc*/saveData.req, which needs no special attention unless you want
to modify the list of EPICS PV's whose values are to be saved with every data
file.  To do this, look for the string "[extraPV]" in the file, and edit the
list of PV's immediately following that string.  If an entry in this list
contains only the PV name, saveData will describe the PV, in the data file,
using the .DESC field of the record that contains that PV.  If a string follows
the PV name, saveData will use the string instead.

</ol>
</ol>

<h2>The synApps utils directory</h2>
<P>The synApps support/utils directory contains a variety of executables
that may be useful in administering and/or using synApps.  Some of these tools are
probably peculiar to the way synApps is used at APS, and may not be of any use

<P><dl>
<dt>changePrefix, doSed

<dd>These are for the application developer's convenience in changing EPICS
prefixes in a user directory.  You must be in the top level of the user
directory to run changePrefix, and you should do a "gnumake clean uninstall"
before running it.

<P>Example of use:
<pre>
    cd $(SYNAPPS)/ioc/1bm
    changePrefix xxx 1bma
</pre>

<dt>copyAdl
<dd>
Look through synApps for .adl files, and copy them all to a specified directory

<P>Example of use:
<pre>
    copyAdl $SYNAPPS/support adl_files
</pre>

<dt>convertIocFiles.py

<dd>This file, and its associates, are intended to help convert an IOC directory
from one version of EPICS to another, by collecting data from an existing IOC
directory, and attempting to correctly edit files in a new IOC directory. See
support/utils/HowToUse_convertIocFiles.txt for more information on this program.

<P><dt>mdautils-src.tar.gz <dd> This tar file contains utility programs for
using data files written by the <b>sscan</b> module's "saveData" program.  These
programs were written by Dohn Arms, and contributed to synApps.

<P><dt>mdaExplorer
<dd>This wxPython program displays the content of MDA files, and directories of
MDA files.  (An MDA file is the scan-data file produced by the synApps <b>sscan</b>
module's saveData software during a scan.)


<P><dt>mdaPythonUtils
<dd>A collection of python programs that read, write, modify, and translate
MDA files.

<P><dt>snapDb
<dd>A wxPython rapid development tool for EPICS databases and MEDM display
files.  This program supports the use of EPICS' run-time programmability
to prototype a EPICS databases, using records loaded into an IOC.  It's
particularly useful for synApps "userCalcs", a collection of various
record types intended for end users to program at run time. 
</dl>


</ol>

<hr>
<address> 
    Suggestions and Comments to: <br> 
    <a href="mailto:mooney@aps.anl.gov">Tim Mooney </a>:
    (mooney@aps.anl.gov) <br> 
	Beamline Controls & Data Acquisition Group<br>
	Advanced Photon Source, Argonne National Laboratory<br>
    Last modified: February 20, 2009
</address> 
</body>
</html>
