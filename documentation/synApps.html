<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<title>synApps</title>
</head>

<body bgcolor="#FFFFFF">

<h1>synApps 5.4</h1>

<P>synApps is a collection of custom EPICS software (source code, EPICS databases,
client scripts, MEDM display files, executables, etc.) intended to support most
of the requirements of an x-ray laboratory or synchrotron-radiation (SR)
experiment station.  Several instances of this application can work together to
support an entire SR beamline.  synApps is also intended to underly additional
software that may be station or beamline specific.

<P>This release of synApps is compatible with EPICS release 3.14.10, Tornado 2.2,
and the following EPICS modules/versions produced and maintained by other
members of the EPICS collaboration:

<P><table border>
<tr><th>Module<th>version<th>description
<tr><td>allenBradley<td>v2-1<td>for communicating with Allen Bradley PLC's (ANL)
<tr><td>ipac<td>v2-10<td>required for IndustryPack support (ANL)
<tr><td>asyn<td>v4-10<td>required by many modules (ANL)
<tr><td>seq<td>v2-0-12<td>for SNL programs in synApps (SLAC)
<tr><td>stream<td>v2-4<td>configurable device support for message-based devices (PSI)
<tr><td>vxStats<td>v1-7-2g<td>vxWorks statistics, modified by us (SNS)
</table>

<P>Previous versions of synApps included and relied on the genSub module.  In
EPICS 3.14.10, a replacement for the genSub record, called the asub record, is
included in base, and synApps has been modified to use it instead of the genSub
record.

<P>For convenience, this distribution includes the module versions listed above,
in place and ready to build, with minor modifications to build files.  A few of
the modules have suffered more substantial modifications to fix problems, add
MEDM displays, etc.

<P>Here's a list of the modules and directories that actually are part of synApps:

<P><table border>
<tr><th>Module/directory<th>description

<tr><td>areaDetector<td>support for area (2-D) detectors, including CCDs, pixel array
              detectors, and online imaging plates.  This module replaces the
			  ccd and pilatus modules, which are nevertheless included in this
			  version of synApps.
<tr><td>autosave<td>save-restore
<tr><td>busy<td>the busy record, previously supplied by the sscan module
<tr><td>calc<td>run-time expression evaluation
<tr><td>camac<td>CAMAC support
<tr><td>ccd<td>scientific CCD detectors, including Bruker, MAR, and Roper
<tr><td>configure<td>(directory) build files, including the top-level make file
<tr><td>dac128V<td>IndustryPack DAC
<tr><td>delaygen<td>delay generators
<tr><td>dxp<td>XIA's DXP digital signal processor
<tr><td>ebrick<td>support and sample application for low-cost PC-104 and uCDIMM based IOC
<tr><td>ip<td>various serial devices
<tr><td>ip330<td>IndustryPack ADC
<tr><td>ipUnidig<td>IndustryPack digital I/O
<tr><td>love<td>Love controllers
<tr><td>mca<td>multichannel analyzers
<tr><td>modbus<td>support for ModBus-protocol devices over TCP, serial RTU, and
              serial ASCII links
<tr><td>motor<td>motors
<tr><td>optics<td>optical table, monochromators, slits, etc.
<tr><td>pilatus<td>supports Dectris pixel-array detector
<tr><td>quadEM<td>4-channel electrometer
<tr><td>sscan<td>sscan record and related software
<tr><td>std<td>misc EPICS software
<tr><td>stream<td>Dirk Zimoch's streamDevice, in a module-flavored wrapper
<tr><td>utils<td>(directory) miscellaneous tools
<tr><td>vac<td>supports vacuum controllers
<tr><td>vme<td>vme-specific support
<tr><td>xxx<td>sample user-application directory
</table>

<P>See support/configure/RELEASE for a complete set of compatible module
versions.

<P>synApps includes software developed by the Beamline Controls & Data
Acquisition and the Accelerator Controls groups of the Advanced Photon Source
(APS); by developers in APS Collaborative Access Teams -- notably, Mark Rivers
(CARS-CAT); and by developers in the EPICS collaboration outside of the APS --
notably, those at the Swiss Light Source/Paul Scherrer Institut, the Diamond
Light Source, the National Synchrotron Light Source, the Australian Light
Source, and the Canadian Light Source.

<P>Aside from EPICS databases, SNL (State Notation Language) programs, and the
like, synApps contains the following code:

<ul>
<li><h3>Record support</h3>
<table border>
<tr><th>Record<th>Description
<tr><td>aCalcout<td>calcout record extended to handle array expressions
<tr><td>busy<td>utility record: calls recGblFwdLink only when its
	VAL field is zero, allowing CA clients, and asyn drivers to
	participate in EPICS putNotify (ca_put_callback()) operations.
<tr><td>dxp<td>XIA's DXP digital signal processor
	Set/read signal-processor parameters
<tr><td>epid<td>Extended version of the PID record, previously in EPICS base.
	Intended for implementing feedback loops
<tr><td>mca<td>support for multichannel analyzers, and some other
	array-valued detectors
<tr><td>motor<td>stepper and servo motors, "soft" motor
<tr><td>sCalcout<td>calcout record extended to handle string expressions,
	links, and values.
<tr><td>scaler<td>scaler bank
<tr><td>sscan<td>Replaces the scan record (Ned Arnold/APS) previously in EPICS
	base. This version uses a modified version of recDynLlib that supports
	dbNotify command completion.  It uses ca_put_callback to do puts, instead of
	ca_put.
<tr><td>scanparm<td>scan parameters for use with the scan record
<tr><td>sseq<td>string-sequence record.  This is a modified version of
	the seq record in base.  This version can link to/from
	either string or numeric PVs, and it can use
	dbCaPutLinkCallback to wait for completion of the
	execution started by one link before going on to the
	next.
<tr><td>swait<td>replaces the wait record previously in EPICS base.
	This version uses a modified version of recDynLlib
	that supports dbNotify command completion.  It uses
	ca_put_callback to do puts, instead of ca_put.
<tr><td>table<td>6-degree-of-freedom optical table
<tr><td>transform<td>like an array of calc records, with output links
<tr><td>vme<td>generic vme record (Mark Rivers/APS/CARS-CAT)
<tr><td>timestamp<td>(written by Stephanie Allison/SLAC) Needed by the vxStats
	module, but apparently not available in a published module.
</table>

<P><li><h3>Device/driver support in or included with synApps</h3>
<table border>
<tr><th>record<th>bus-type<th>codename<th>username
<tr><td>acalcout   <td>CONSTANT  <td>devaCalcoutSoft              <td>Soft Channel
<tr><td>ai         <td>AB_IO     <td>devAiAb1771Ife               <td>AB-1771IFE
<tr><td>ai         <td>AB_IO     <td>devAiAb1771Ife0to5V          <td>AB-1771IFE-0to5Volt
<tr><td>ai         <td>AB_IO     <td>devAiAb1771IfeMa             <td>AB-1771IFE-4to20MA
<tr><td>ai         <td>AB_IO     <td>devAiAb1771IfeSe             <td>AB-1771IFE-SE
<tr><td>ai         <td>AB_IO     <td>devAiAb1771Il                <td>AB-1771IL-Analog In
<tr><td>ai         <td>AB_IO     <td>devAiAb1771IrCopper          <td>AB-1771RTD-Copper
<tr><td>ai         <td>AB_IO     <td>devAiAb1771IrPlatinum        <td>AB-1771RTD-Platinum
<tr><td>ai         <td>AB_IO     <td>devAiAb1771Ixe               <td>AB-1771IXE-Millivolt In
<tr><td>ai         <td>AB_IO     <td>devAiAbSlcDcm                <td>AB-SLC500DCM
<tr><td>ai         <td>AB_IO     <td>devAiAbSlcDcmSigned          <td>AB-SLC500DCM-Signed
<tr><td>ai         <td>BBGPIB_IO <td>devAiAX301                   <td>PZT Bug
<tr><td>ai         <td>CONSTANT  <td>devAiTodSeconds              <td>Sec Past Epoch
<tr><td>ai         <td>GPIB_IO   <td>devAiGP307Gpib               <td>Vg307 GPIB Instrument
<tr><td>ai         <td>GPIB_IO   <td>devAiHeidAWE1024             <td>Heidenhein Encoder
<tr><td>ai         <td>GPIB_IO   <td>devAiKeithleyDMM199          <td>KeithleyDMM199
<tr><td>ai         <td>GPIB_IO   <td>devGpib                      <td>GPIB init/report
<tr><td>ai         <td>INST_IO   <td>asynAiFloat64                <td>asynFloat64
<tr><td>ai         <td>INST_IO   <td>asynAiFloat64Average         <td>asynFloat64Average
<tr><td>ai         <td>INST_IO   <td>asynAiInt32                  <td>asynInt32
<tr><td>ai         <td>INST_IO   <td>asynAiInt32Average           <td>asynInt32Average
<tr><td>ai         <td>INST_IO   <td>devAiAb1791                  <td>Allen Bradley 1791
<tr><td>ai         <td>INST_IO   <td>devAiAbDcm                   <td>Ab Dcm
<tr><td>ai         <td>INST_IO   <td>devAiClusts                  <td>VX stats clusts
<tr><td>ai         <td>INST_IO   <td>devAiHeidND261               <td>asyn ai HeidND261
<tr><td>ai         <td>INST_IO   <td>devAiMKS                     <td>HPS SensaVac 937
<tr><td>ai         <td>INST_IO   <td>devAiMPC                     <td>asyn MPC
<tr><td>ai         <td>INST_IO   <td>devAiStats                   <td>VX stats
<tr><td>ai         <td>INST_IO   <td>devAiStrParm                 <td>asyn ai stringParm
<tr><td>ai         <td>INST_IO   <td>devAiTPG261                  <td>asyn TPG261
<tr><td>ai         <td>INST_IO   <td>devAiTelevac                 <td>asyn Televac
<tr><td>ai         <td>INST_IO   <td>devInterfaceAI1              <td>InterfaceAI1
<tr><td>ai         <td>VME_IO    <td>devAiA32Vme                  <td>Generic A32 VME
<tr><td>ai         <td>VME_IO    <td>devAiAvmeMRD                 <td>devAvmeMRD
<tr><td>ai         <td>VME_IO    <td>devAiBunchClkGen             <td>APS Bunch Clock
<tr><td>ai         <td>VME_IO    <td>devAiVaroc                   <td>ESRF Varoc SSI Encoder Iface
<tr><td>ai         <td>VME_IO    <td>devIK320Ai                   <td>Heidenhain IK320
<tr><td>ai         <td>VME_IO    <td>devIK320GroupAi              <td>Heidenhain IK320 Group
<tr><td>ao         <td>AB_IO     <td>devAoAb1771Ofe               <td>AB-1771OFE
<tr><td>ao         <td>AB_IO     <td>devAoAbSlcDcm                <td>AB-SLC500DCM
<tr><td>ao         <td>BBGPIB_IO <td>devAoAX301                   <td>PZT Bug
<tr><td>ao         <td>GPIB_IO   <td>devAoHeidAWE1024             <td>Heidenhein Encoder
<tr><td>ao         <td>GPIB_IO   <td>devAoKeithleyDMM199          <td>KeithleyDMM199
<tr><td>ao         <td>INST_IO   <td>asynAoFloat64                <td>asynFloat64
<tr><td>ao         <td>INST_IO   <td>asynAoInt32                  <td>asynInt32
<tr><td>ao         <td>INST_IO   <td>devAoAb1791                  <td>Allen Bradley 1791
<tr><td>ao         <td>INST_IO   <td>devAoAbDcm                   <td>Ab Dcm
<tr><td>ao         <td>INST_IO   <td>devAoEurotherm               <td>asyn ao Eurotherm
<tr><td>ao         <td>INST_IO   <td>devAoMPC                     <td>asyn MPC
<tr><td>ao         <td>INST_IO   <td>devAoStats                   <td>VX stats
<tr><td>ao         <td>INST_IO   <td>devAoStrParm                 <td>asyn ao stringParm
<tr><td>ao         <td>INST_IO   <td>devAoTPG261                  <td>asyn TPG261
<tr><td>ao         <td>INST_IO   <td>devInterfaceAO1              <td>InterfaceAO1
<tr><td>ao         <td>VME_IO    <td>devAoA32Vme                  <td>Generic A32 VME
<tr><td>ao         <td>VME_IO    <td>devAoAvme9210                <td>AVME-9210
<tr><td>ao         <td>VME_IO    <td>devAoBunchClkGen             <td>APS Bunch Clock
<tr><td>ao         <td>VME_IO    <td>devAoVMI4116                 <td>VMIVME-4116
<tr><td>asyn       <td>INST_IO   <td>asynRecordDevice             <td>asynRecordDevice
<tr><td>bi         <td>AB_IO     <td>devBiAb                      <td>AB-Binary Input
<tr><td>bi         <td>AB_IO     <td>devBiAb16                    <td>AB-16 bit BI
<tr><td>bi         <td>AB_IO     <td>devBiAb32                    <td>AB-32 bit BI
<tr><td>bi         <td>GPIB_IO   <td>devBiGP307Gpib               <td>Vg307 GPIB Instrument
<tr><td>bi         <td>GPIB_IO   <td>devBiHeidAWE1024             <td>Heidenhein Encoder
<tr><td>bi         <td>GPIB_IO   <td>devBiKeithleyDMM199          <td>KeithleyDMM199
<tr><td>bi         <td>INST_IO   <td>asynBiInt32                  <td>asynInt32
<tr><td>bi         <td>INST_IO   <td>asynBiUInt32Digital          <td>asynUInt32Digital
<tr><td>bi         <td>INST_IO   <td>devBiAbDcm                   <td>Ab Dcm
<tr><td>bi         <td>INST_IO   <td>devBiMPC                     <td>asyn MPC
<tr><td>bi         <td>INST_IO   <td>devBiStrParm                 <td>asyn bi stringParm
<tr><td>bi         <td>INST_IO   <td>devBiTPG261                  <td>asyn TPG261
<tr><td>bi         <td>INST_IO   <td>devBiTelevac                 <td>asyn Televac
<tr><td>bi         <td>VME_IO    <td>devBiA32Vme                  <td>Generic A32 VME
<tr><td>bi         <td>VME_IO    <td>devBiAvme9440                <td>AVME9440 I
<tr><td>bi         <td>VME_IO    <td>devBiAvmeMRD                 <td>devAvmeMRD
<tr><td>bi         <td>VME_IO    <td>devBiBunchClkGen             <td>APS Bunch Clock
<tr><td>bi         <td>VME_IO    <td>devBiHP10895LaserAxis        <td>HP interferometer
<tr><td>bo         <td>AB_IO     <td>devBoAb                      <td>AB-Binary Output
<tr><td>bo         <td>AB_IO     <td>devBoAb16                    <td>AB-16 bit BO
<tr><td>bo         <td>AB_IO     <td>devBoAb32                    <td>AB-32 bit BO
<tr><td>bo         <td>BBGPIB_IO <td>devBoAX301                   <td>PZT Bug
<tr><td>bo         <td>GPIB_IO   <td>devBoGP307Gpib               <td>Vg307 GPIB Instrument
<tr><td>bo         <td>GPIB_IO   <td>devBoHeidAWE1024             <td>Heidenhein Encoder
<tr><td>bo         <td>GPIB_IO   <td>devBoKeithleyDMM199          <td>KeithleyDMM199
<tr><td>bo         <td>INST_IO   <td>asynBoInt32                  <td>asynInt32
<tr><td>bo         <td>INST_IO   <td>asynBoUInt32Digital          <td>asynUInt32Digital
<tr><td>bo         <td>INST_IO   <td>devBoAbDcm                   <td>Ab Dcm
<tr><td>bo         <td>INST_IO   <td>devBoMPC                     <td>asyn MPC
<tr><td>bo         <td>INST_IO   <td>devBoStrParm                 <td>asyn bo stringParm
<tr><td>bo         <td>INST_IO   <td>devBoTPG261                  <td>asyn TPG261
<tr><td>bo         <td>VME_IO    <td>devBoA32Vme                  <td>Generic A32 VME
<tr><td>bo         <td>VME_IO    <td>devBoAvme9440                <td>AVME9440 O
<tr><td>bo         <td>VME_IO    <td>devBoAvmeMRD                 <td>devAvmeMRD
<tr><td>bo         <td>VME_IO    <td>devBoBunchClkGen             <td>APS Bunch Clock
<tr><td>bo         <td>VME_IO    <td>devBoHP10895LaserAxis        <td>HP interferometer
<tr><td>busy       <td>CONSTANT  <td>devBusySoft                  <td>Soft Channel
<tr><td>busy       <td>INST_IO   <td>asynBusyInt32                <td>asynInt32
<tr><td>epid       <td>CONSTANT  <td>devEpidSoft                  <td>Soft Channel
<tr><td>epid       <td>INST_IO   <td>devEpidFast                  <td>Fast Epid
<tr><td>longin     <td>AB_IO     <td>devLiAbSlcDcm                <td>AB-SLC500DCM
<tr><td>longin     <td>GPIB_IO   <td>devLiHeidAWE1024             <td>Heidenhein Encoder
<tr><td>longin     <td>GPIB_IO   <td>devLiKeithleyDMM199          <td>KeithleyDMM199
<tr><td>longin     <td>INST_IO   <td>asynLiInt32                  <td>asynInt32
<tr><td>longin     <td>INST_IO   <td>asynLiUInt32Digital          <td>asynUInt32Digital
<tr><td>longin     <td>INST_IO   <td>devLiAbDcm                   <td>Ab Dcm
<tr><td>longin     <td>INST_IO   <td>devLiStrParm                 <td>asyn li stringParm
<tr><td>longin     <td>VME_IO    <td>devLiA32Vme                  <td>Generic A32 VME
<tr><td>longin     <td>VME_IO    <td>devLiAvmeMRD                 <td>devAvmeMRD
<tr><td>longin     <td>VME_IO    <td>devLiHP10895LaserAxis        <td>HP interferometer
<tr><td>longout    <td>AB_IO     <td>devLoAbSlcDcm                <td>AB-SLC500DCM
<tr><td>longout    <td>BBGPIB_IO <td>devLoAX301                   <td>PZT Bug
<tr><td>longout    <td>GPIB_IO   <td>devLoHeidAWE1024             <td>Heidenhein Encoder
<tr><td>longout    <td>GPIB_IO   <td>devLoKeithleyDMM199          <td>KeithleyDMM199
<tr><td>longout    <td>INST_IO   <td>asynLoInt32                  <td>asynInt32
<tr><td>longout    <td>INST_IO   <td>asynLoUInt32Digital          <td>asynUInt32Digital
<tr><td>longout    <td>INST_IO   <td>devLoAbDcm                   <td>Ab Dcm
<tr><td>longout    <td>INST_IO   <td>devLoStrParm                 <td>asyn lo stringParm
<tr><td>longout    <td>VME_IO    <td>devLoA32Vme                  <td>Generic A32 VME
<tr><td>longout    <td>VME_IO    <td>devLoHP10895LaserAxis        <td>HP interferometer
<tr><td>mbbi       <td>AB_IO     <td>devMbbiAb                    <td>AB-Binary Input
<tr><td>mbbi       <td>AB_IO     <td>devMbbiAb16                  <td>AB-16 bit BI
<tr><td>mbbi       <td>AB_IO     <td>devMbbiAb32                  <td>AB-32 bit BI
<tr><td>mbbi       <td>AB_IO     <td>devMbbiAbAdapterStat         <td>AB-Adapter Status
<tr><td>mbbi       <td>AB_IO     <td>devMbbiAbCardStat            <td>AB-Card Status
<tr><td>mbbi       <td>GPIB_IO   <td>devMbbiHeidAWE1024           <td>Heidenhein Encoder
<tr><td>mbbi       <td>GPIB_IO   <td>devMbbiKeithleyDMM199        <td>KeithleyDMM199
<tr><td>mbbi       <td>INST_IO   <td>asynMbbiInt32                <td>asynInt32
<tr><td>mbbi       <td>INST_IO   <td>asynMbbiUInt32Digital        <td>asynUInt32Digital
<tr><td>mbbi       <td>INST_IO   <td>devMbbiAbDcm                 <td>Ab Dcm
<tr><td>mbbi       <td>INST_IO   <td>devMbbiTPG261                <td>asyn TPG261
<tr><td>mbbi       <td>VME_IO    <td>devMbbiA32Vme                <td>Generic A32 VME
<tr><td>mbbi       <td>VME_IO    <td>devMbbiAvme9440              <td>AVME9440 I
<tr><td>mbbi       <td>VME_IO    <td>devMbbiAvmeMRD               <td>devAvmeMRD
<tr><td>mbbi       <td>VME_IO    <td>devMbbiHP10895LaserAxis      <td>HP interferometer
<tr><td>mbbiDirect <td>AB_IO     <td>devMbbiDirectAb              <td>AB-Binary Input
<tr><td>mbbiDirect <td>AB_IO     <td>devMbbiDirectAb16            <td>AB-16 bit BI
<tr><td>mbbiDirect <td>AB_IO     <td>devMbbiDirectAb32            <td>AB-32 bit BI
<tr><td>mbbiDirect <td>INST_IO   <td>asynMbbiDirectUInt32Digital  <td>asynUInt32Digital
<tr><td>mbbo       <td>AB_IO     <td>devMbboAb                    <td>AB-Binary Output
<tr><td>mbbo       <td>AB_IO     <td>devMbboAb16                  <td>AB-16 bit BO
<tr><td>mbbo       <td>AB_IO     <td>devMbboAb32                  <td>AB-32 bit BO
<tr><td>mbbo       <td>GPIB_IO   <td>devMbboHeidAWE1024           <td>Heidenhein Encoder
<tr><td>mbbo       <td>GPIB_IO   <td>devMbboKeithleyDMM199        <td>KeithleyDMM199
<tr><td>mbbo       <td>INST_IO   <td>asynMbboInt32                <td>asynInt32
<tr><td>mbbo       <td>INST_IO   <td>asynMbboUInt32Digital        <td>asynUInt32Digital
<tr><td>mbbo       <td>INST_IO   <td>devMbboAbDcm                 <td>Ab Dcm
<tr><td>mbbo       <td>INST_IO   <td>devMbboMPC                   <td>asyn MPC
<tr><td>mbbo       <td>INST_IO   <td>devMbboTPG261                <td>asyn TPG261
<tr><td>mbbo       <td>VME_IO    <td>devIK320Dir                  <td>Heidenhain IK320 Sign
<tr><td>mbbo       <td>VME_IO    <td>devIK320Funct                <td>Heidenhain IK320 Command
<tr><td>mbbo       <td>VME_IO    <td>devIK320ModeX3               <td>Heidenhain IK320 X3 Mode
<tr><td>mbbo       <td>VME_IO    <td>devMbboA32Vme                <td>Generic A32 VME
<tr><td>mbbo       <td>VME_IO    <td>devMbboAvme9440              <td>AVME9440 O
<tr><td>mbbo       <td>VME_IO    <td>devMbboHP10895LaserAxis      <td>HP interferometer
<tr><td>mbboDirect <td>AB_IO     <td>devMbboDirectAb              <td>AB-Binary Output
<tr><td>mbboDirect <td>AB_IO     <td>devMbboDirectAb16            <td>AB-16 bit BO
<tr><td>mbboDirect <td>AB_IO     <td>devMbboDirectAb32            <td>AB-32 bit BO
<tr><td>mbboDirect <td>INST_IO   <td>asynMbboDirectUInt32Digital  <td>asynUInt32Digital
<tr><td>mca        <td>CONSTANT  <td>devMCA_soft                  <td>Soft Channel
<tr><td>mca        <td>INST_IO   <td>devMcaAsyn                   <td>asynMCA
<tr><td>mca        <td>VME_IO    <td>devSTR7201                   <td>Struck STR7201 MCS
<tr><td>motor      <td>CONSTANT  <td>devMotorSoft                 <td>Soft Channel
<tr><td>motor      <td>INST_IO   <td>devMotorAsyn                 <td>asynMotor
<tr><td>motor      <td>VME_IO    <td>devE500                      <td>E500
<tr><td>motor      <td>VME_IO    <td>devESP300                    <td>ESP300
<tr><td>motor      <td>VME_IO    <td>devIM483PL                   <td>IM483PL
<tr><td>motor      <td>VME_IO    <td>devIM483SM                   <td>IM483SM
<tr><td>motor      <td>VME_IO    <td>devMAXv                      <td>OMS MAXv
<tr><td>motor      <td>VME_IO    <td>devMCB4B                     <td>ACS MCB-4B
<tr><td>motor      <td>VME_IO    <td>devMCDC2805                  <td>MCDC2805
<tr><td>motor      <td>VME_IO    <td>devMDrive                    <td>MDrive
<tr><td>motor      <td>VME_IO    <td>devMM3000                    <td>MM3000
<tr><td>motor      <td>VME_IO    <td>devMM4000                    <td>MM4000
<tr><td>motor      <td>VME_IO    <td>devMVP2001                   <td>MVP2001
<tr><td>motor      <td>VME_IO    <td>devMicos                     <td>Micos MoCo
<tr><td>motor      <td>VME_IO    <td>devMotorSim                  <td>Motor Simulation
<tr><td>motor      <td>VME_IO    <td>devOMS                       <td>OMS VME8/44
<tr><td>motor      <td>VME_IO    <td>devOms58                     <td>OMS VME58
<tr><td>motor      <td>VME_IO    <td>devOmsPC68                   <td>OMS PC68/78
<tr><td>motor      <td>VME_IO    <td>devPC6K                      <td>PC6K
<tr><td>motor      <td>VME_IO    <td>devPIC630                    <td>PI C630
<tr><td>motor      <td>VME_IO    <td>devPIC662                    <td>PIC662
<tr><td>motor      <td>VME_IO    <td>devPIC844                    <td>PIC844
<tr><td>motor      <td>VME_IO    <td>devPIC848                    <td>PIC848
<tr><td>motor      <td>VME_IO    <td>devPIC862                    <td>PIC862
<tr><td>motor      <td>VME_IO    <td>devPIE516                    <td>PIE516
<tr><td>motor      <td>VME_IO    <td>devPIE710                    <td>PIE710
<tr><td>motor      <td>VME_IO    <td>devPIE816                    <td>PIE816
<tr><td>motor      <td>VME_IO    <td>devPM304                     <td>Mclennan PM304
<tr><td>motor      <td>VME_IO    <td>devPM500                     <td>PM500
<tr><td>motor      <td>VME_IO    <td>devPMNC87xx                  <td>PMNC87xx
<tr><td>motor      <td>VME_IO    <td>devPmac                      <td>PMAC
<tr><td>scalcout   <td>CONSTANT  <td>devsCalcoutSoft              <td>Soft Channel
<tr><td>scaler     <td>INST_IO   <td>devScalerAsyn                <td>Asyn Scaler
<tr><td>scaler     <td>VME_IO    <td>devScaler                    <td>Joerger VSC8/16
<tr><td>scaler     <td>VME_IO    <td>devScalerCamac               <td>CAMAC scaler
<tr><td>scaler     <td>VME_IO    <td>devScalerSTR7201             <td>Struck STR7201 Scaler
<tr><td>scaler     <td>VME_IO    <td>devScaler_VS                 <td>Joerger VS
<tr><td>stringin   <td>CONSTANT  <td>devSiTodString               <td>Time of Day
<tr><td>stringin   <td>GPIB_IO   <td>devSiGP307Gpib               <td>Vg307 GPIB Instrument
<tr><td>stringin   <td>GPIB_IO   <td>devSiHeidAWE1024             <td>Heidenhein Encoder
<tr><td>stringin   <td>GPIB_IO   <td>devSiKeithleyDMM199          <td>KeithleyDMM199
<tr><td>stringin   <td>INST_IO   <td>asynSiOctetCmdResponse       <td>asynOctetCmdResponse
<tr><td>stringin   <td>INST_IO   <td>asynSiOctetRead              <td>asynOctetRead
<tr><td>stringin   <td>INST_IO   <td>asynSiOctetWriteRead         <td>asynOctetWriteRead
<tr><td>stringin   <td>INST_IO   <td>devSiMPC                     <td>asyn MPC
<tr><td>stringin   <td>INST_IO   <td>devSiSeq                     <td>Sequencer Internals
<tr><td>stringin   <td>INST_IO   <td>devSiStrParm                 <td>asyn si stringParm
<tr><td>stringin   <td>INST_IO   <td>devSiTPG261                  <td>asyn TPG261
<tr><td>stringin   <td>INST_IO   <td>devStringinStats             <td>VX stats
<tr><td>stringout  <td>GPIB_IO   <td>devSoHeidAWE1024             <td>Heidenhein Encoder
<tr><td>stringout  <td>GPIB_IO   <td>devSoKeithleyDMM199          <td>KeithleyDMM199
<tr><td>stringout  <td>INST_IO   <td>asynSoOctetWrite             <td>asynOctetWrite
<tr><td>stringout  <td>INST_IO   <td>devSoEurotherm               <td>asyn so Eurotherm
<tr><td>stringout  <td>INST_IO   <td>devSoMPC                     <td>asyn MPC
<tr><td>stringout  <td>INST_IO   <td>devSoStrParm                 <td>asyn so stringParm
<tr><td>stringout  <td>VME_IO    <td>devIK320Parm                 <td>Heidenhain IK320 Parameter
<tr><td>swait      <td>CONSTANT  <td>devSWaitIoEvent              <td>Soft Channel
<tr><td>waveform   <td>INST_IO   <td>asynFloat32ArrayWfIn         <td>asynFloat32ArrayIn
<tr><td>waveform   <td>INST_IO   <td>asynFloat32ArrayWfOut        <td>asynFloat32ArrayOut
<tr><td>waveform   <td>INST_IO   <td>asynFloat64ArrayWfIn         <td>asynFloat64ArrayIn
<tr><td>waveform   <td>INST_IO   <td>asynFloat64ArrayWfOut        <td>asynFloat64ArrayOut
<tr><td>waveform   <td>INST_IO   <td>asynInt16ArrayWfIn           <td>asynInt16ArrayIn
<tr><td>waveform   <td>INST_IO   <td>asynInt16ArrayWfOut          <td>asynInt16ArrayOut
<tr><td>waveform   <td>INST_IO   <td>asynInt32ArrayWfIn           <td>asynInt32ArrayIn
<tr><td>waveform   <td>INST_IO   <td>asynInt32ArrayWfOut          <td>asynInt32ArrayOut
<tr><td>waveform   <td>INST_IO   <td>asynInt8ArrayWfIn            <td>asynInt8ArrayIn
<tr><td>waveform   <td>INST_IO   <td>asynInt8ArrayWfOut           <td>asynInt8ArrayOut
<tr><td>waveform   <td>INST_IO   <td>asynWfOctetCmdResponse       <td>asynOctetCmdResponse
<tr><td>waveform   <td>INST_IO   <td>asynWfOctetRead              <td>asynOctetRead
<tr><td>waveform   <td>INST_IO   <td>asynWfOctetWrite             <td>asynOctetWrite
<tr><td>waveform   <td>INST_IO   <td>asynWfOctetWriteRead         <td>asynOctetWriteRead
<tr><td>waveform   <td>VME_IO    <td>devWfBunchClkGen             <td>APS Bunch Clock
</table>

<P><li><h3>Miscellaneous C code</h3>
<dl>
<dt>aCalcPostfix, aCalcPerform
	sCalcPostfix, sCalcPerform
	<dd>Support for run-time expression evaluation
<dt>recDynLink
	<dd>Backward compatible extension of the dynamic-link software
		previously in EPICS base.  (New code should probably use
		dbCaPutlinkCallback(), instead of recDynLink.)
<dt>save_restore, dbrestore
	<dd>Automatic parameter save and boot-time restore.
<dt>saveData
	<dd>Saves scan data to files on an NFS-mounted disk (vxWorks), or to
	a local disk (other operating systems).
</dl>

<P><li><h3>Documentation</h3>

	<P>In addition to this top-level documentation, synApps modules have their
	own documentation directories, and the xxx module contains examples of
	how most of the software is loaded and run. Some modules have their own
	example iocBoot directories.


<P><li><h3>Miscellaneous</h3>

	<P>The synApps support/utils directory contains a variety of scripts,
	programs, etc., that some have found useful.
</ul>

<hr>
<h2>How to deploy synApps</h2>

<P>Although synApps is distributed as a single 'support' directory, it's
normally used as a two-part system: the 'support' tree, and a 'user' tree.  The
support tree can be installed on a read-only file system, along with EPICS base
and other modules, and used from there by one or more user trees, each of which
begins as a copy (or a collection of copies) of the module 'support/xxx', and is
customized/extended by the end user to particular applications and sets of
hardware.

<P>I'm not being very precise about what is meant by a user tree, because there
are a number of reasonable variations.  At the simplest, a single copy of the
xxx module, which supports a single IOC, is a user tree.  If several IOC's
cooperate to serve a single application (such as a synchrotron beamline), one
might make several independent copies of the xxx directory, or one might extend
the xxx copy to contain multiple xxxApp directories, and multiple iocBoot/iocxxx
directories.  At APS, we have several top-level user trees, each of which
contains a number of copies of xxx, most of which, in turn, contain multiple
xxxApp and iocBoot/iocxxx directories.

<blockquote><i>If you haven't run into the term 'IOC' yet, it stands for
Input/Output Controller.  Initially, this was a VME crate with a processor
running EPICS under the VxWorks operating system, but beginning with EPICS 3.14,
an IOC can also be a set of tasks on a workstation running Linux, Windows,
Cygwin, Solaris, RTEMS, Mac OS, and, no doubt, other operating systems.</i>
</blockquote>

<P>Here's what a complete installation might look like (much detail omitted)
with all the files you will have to edit before you can build or boot an IOC.
In the following, 'WIN32' means native Windows, as distinguished from Windows
used via the Cygwin unix-like environment:

<P><h4> The support tree</h4>
<pre>
support/
    Makefile                            <-- EDIT to build
    Makefile.win32-x86                  <-- EDIT to build for WIN32
    all_adl/
    allenBradley/
    areaDetector/
    asyn/
    busy/
    calc/
    camac/
    ccd/
    configure/
        CONFIG_SITE                     <-- EDIT to build
        RELEASE                         <-- EDIT to build
        RELEASE.win32-x86               <-- EDIT to build for WIN32
        ...
    dac128V/
    delaygen/
    documentation/
    dxp/
    ebrick/
    ip/
    ip330/
    ipUnidig/
    ipac/
        drvIpac/drvIpac.dbd             <-- EDIT to build
    love/
    mca/
    modbus/
    motor/
        motorApp/
        Makefile                        <-- EDIT to build
    optics/
    pilatus/
    quadEM/
    seq/
    sscan/
    std/
    stream/
    utils/
    vac/
    vme/
    vxStats/
    xxx/

</pre>
<P><h4> The user tree</h4>
<pre>
ioc/
    1bm/
        Makefile
        bin/
        configure/
            RELEASE                     <-- EDIT to build
            RELEASE.win32-x86           <-- EDIT to build for WIN32
        dbd/
        iocBoot/
            Makefile
            nfsCommands
            ioc1bma/
                Makefile
                camac.cmd
                canberra_1.cmd
                canberra_13.cmd
                canberra_3.cmd
                dac128V.cmd
                dxp_16.cmd
                industryPack.cmd
                ip330.cmd
                ipUnidig.cmd
                quadEM.cmd
                save_restore.cmd
                serial.cmd
                vme.cmd
                st.cmd
                basic_motor.substitutions
                canberra_13.substitutions
                canberra_3.substitutions
                dac128V.substitutions
                dxp_16.substitutions
                ip330Scan.substitutions
                ipUnidig.substitutions
                motor.substitutions
                picMot.substitutions
                pid_fast.substitutions
                pid_slow.substitutions
                quadEM_pid.substitutions
                scanParms.substitutions
                vxStats.substitutions
                auto_positions.req 
                auto_settings.req
                autosave/
                cdCommands or envPaths
                saveData.req 
            ioc1bmb/
                <much like ioc1bma>
        release.pl
        setup_epics_common
        start_epics_1bma
        start_epics_1bmb
        1bmaApp/
        1bmbApp/

    1id/
        <much like 1bm>
    ...
</pre>

<P>As shown above, the following files can or must be edited to modify the way
the synApps support tree is built:

<dl>
<dt>support/Makefile
    <dd>comment out any modules you don't want to build

<P><dt>support/configure/RELEASE
	<dd>edit the definitions of EPICS_BASE and SUPPORT with the correct paths to
	these directories on your system.  Note that you should run "make release"
	in the support directory after modifying this file, to propagate the changes
	down to the modules named in support/Makefile.

<P><dt>support/configure/CONFIG_SITE
	<dd>Edit to set the following variables, which control what will be built:
	The supported values for these variables are YES and NO.
	<dl>
	<dt>LINUX_USB_INSTALLED
		<dd>This controls the build of the dxp module.  If usb is not installed
		for developers, then parts of dxp/dxpApp/handelSrc will not be built,
		and the example application executable, dxpApp, will not be built, so
		dxp/iocBoot cannot be used.

	<dt>LINUX_NET_INSTALLED
		<dd>This controls the build of the mca module, specifically, support for
		the Canberra AIM hardware.

	<dt>LINUX_TIFF_INSTALLED
		<dd>This controls the build of the areaDetector module, and is understood
		to indicate whether libtiff.a, libjpeg.a, and libz.a are all
		installed.  If they are not installed, areaDetector will not build
		the following directories that requires them: prosilicaSrc, pilatusSrc,
		and marCCDSrc.
	</dl>

<dt>ipac/&lt;version&gt;/drvIpac/drvIpac.dbd
	<dd>uncomment registrar() commands for IndustryPack carriers you plan to use.

<P><dt>motor/&lt;version&gt;/motorApp/Makefile
	<dd>comment or uncomment to select the motor support you want to build.
</dl>


<P>The following files must be edited in a user tree
<dl>
<dt>ioc/&lt;appname&gt;/configure/RELEASE<br>
ioc/&lt;appname&gt;/configure/RELEASE.win32-x86 (WIN32 only)
	<dd>edit the definition of SUPPORT with the correct path to the support tree
</dl>

<hr>
<h2> How to build synApps</h2>
<ol>
<h3><li>System configuration</h3>

<P>Before building synApps, you should ensure that your system has the
libraries, header files, etc. required to build the modules you want
to build.  Here's a list of the operating-system dependencies we've
documented so far.

<blockquote><i>Please help: new users are particularly well placed to
help us complete this list.  Long-time developers typically have lots of
things correctly configured that they don't even remember configuring.</i>
</blockquote>

<ul>
<li>Linux:
<dl>
<dt>libtiff.a,libjpeg.a, libz.a, and associated header files<dd>needed for the areaDetector module
<dt>libusb.a, and associated header files<dd>needed for the dxp module
</dl>

<li>Cygwin:
<P>Cygwin is configured from a menu of choices organized by function.  You will
need the following components from the following menu headings:
	<ul>
		<li>base
		<ul>
			<li>All default components
		</ul>
		<li>devel
		<ul> 
			<li>gcc-core
			<li>gcc-g++
			<li>libncurses-devel
			<li>make
			<li>readline
		</ul>
		<li>interpreters
		<ul>
			<li>perl
		</ul>
		<li>libs
		<ul>
			<li>ncurses
		<li>sunrpc
		</ul>
		<li>misc
		<ul>
			<li>DLPORTIO needed for the dxp module
		</ul>
	</ul>

<P><li>Windows:
<dl>
<dt>DLPORTIO<dd>needed for the dxp module
</dl>

</ul>

<P><h3><li>Building and configuring the support tree</h3>


<P>If you have a built copy of EPICS base 3.14.10 or later, then building the
synApps support tree should be very simple:

<ol>
<li>Edit support/Makefile, support/configure/RELEASE, and
   support/configure/CONFIG_SITE, as noted above.

<li>Edit ipac/&lt;version&gt;/drvIpac/drvIpac.dbd, and
   motor/&lt;version&gt;/motorApp/Makefile, as noted above

<li>Set the environment variable EPICS_HOST_ARCH to the architecture (and
   compiler, if there is a choice) on which you are building. I used
   solaris-sparc, linux-x86, and cygwin-x86.

<li>In support, run "make release".

<li>In support, run make.  (You should be able to use "make -j" to build
   synApps much more quickly than it has previously built.)
</ol>

<P>You should use the same GNU Make executable that was used to build EPICS
base.  You may need $(EPICS_BASE)/bin/&lt;arch&gt; in your path, and you may need
$(EPICS_BASE)/lib/&lt;arch&gt; in LD_LIBRARY_PATH.

<P>When executed in the support directory, "make release" will go to all
of the modules support/Makefile knows about and edit the configure/RELEASE
files in those modules so that they all build from the same versions of EPICS
base and other known modules.

<P>Typically, make will not succeed the first time, because you will not have
all of the required system support.  If you find that you cannot build some
synApps module, you should comment it out of both support/Makefile, and
support/configure/RELEASE (RELEASE.win32-x86 for WIN32 builds).

<P><h3><li>Building and configuring a user tree</h3>

<P>Once synApps' support directory has built without errors, the xxx module will
have been configured and tested so that you can use it to build a user tree to
support your IOCs.  (I.e., xxx/configure/RELEASE will have correct, absolute
paths to base and synApps.)  Clean and uninstall xxx, and tar a copy of the
directory for use as a template.  To use the template, untar it, cd to its
top-level directory and run utils/changePrefix to change the PV-name prefix from
xxx to whatever you want.  (Note you must have support/utils in your command
path, or you could copy utils/changePrefix and utils/doSed to a directory that
is in your command path.  Note that changePrefix is synApps-version specific.)

<P>Here's what I do:
<pre>
	# Do once when synApps is built:
	cd $(SYNAPPS)/support/xxx
	setenv EPICS_HOST_ARCH <host architecture>
	gnumake clean uninstall
	tar cvf ../xxx.tar *

	# Do whenever a new user tree ('1bm', in this example) is needed:
	cd $(SYNAPPS)/ioc
	mkdir 1bm
	cd 1bm
	tar xf $(SYNAPPS)/support/xxx.tar
	changePrefix xxx 1bma
	mv iocBoot/iocvxWorks iocBoot/ioc1bma
	edit iocBoot/ioc1bma/Makefile to specify the IOC processor type
	gnumake
</pre>

<P>To put a second application, 1bmb, into 1bm, I run the following commands:
<pre>
	cd $(SYNAPPS)/ioc
	mkdir temp
	cd temp
	tar xf $(SYNAPPS)/support/xxx.tar
	changePrefix xxx 1bmb
	mv iocBoot/iocvxWorks iocBoot/ioc1bmb
	edit iocBoot/ioc1bmb/Makefile to specify the ioc processor type
	cd $(SYNAPPS)/ioc
	mv temp/1bmbApp/start_epics_1bmb 1bm
	mv temp/1bmbApp 1bm
	mv temp/iocBoot/ioc1bmb 1bm/iocBoot
	rm -rf temp
	cd 1bm
	gnumake
</pre>

<P>Edit the files above to agree with your hardware, to load the databases you
want, etc., set up the IOC processor's parameters to load from the software
just configured, and boot the crate.  If you don't know how to do this, read
on.
</ol>

<hr>
<h2>How to make synApps work</h2>
<ol>
<h3><li>Setting up the IOC (vxWorks)</h3>

<P>Ensure that $(EPICS_BASE)/bin/&lt;arch&gt;/caRepeater gets run when your
workstation boots.  If you have no way of doing this, you can run it manually
or put the command in your .login file.

<P>Setup your host system to work with the EPICS processor.  See the "VxWorks
Programmer's Guide" if you have a copy.  Here's what we do (on a Sun
workstation):
<ul>
<li>Add a user named <vx_username> with the password <vx_password>.
    The user has nothing in its home directory, and very few priviledges.

<li>Connect an ethernet cable to the processor.

<li>Setup the workstation to use a serial port at 9600 baud.
    Connect a serial cable from the workstation to the VME
    processor's "Console" port.

<li>Start up an "xterm" on the workstation and type
    <pre>cu -lttya</pre>
    <P>(On some workstations we must type "<code>cu -lcua/a</code>".)
    This gets the xterm communicating with the crate processor.

<li>Turn the crate on.  The crate processor says "Press any key to
    stop auto-boot..." and a number counting down from 7.  Pressing
    a key gets the prompt "[VxWorks Boot]:"

<li>Type "p" to see the current boot parameters,  type "c" to
    change them.  Here are sample boot parameters 
<pre>
    boot device          : dc 
    processor number     : 0 
    host name            : <server> 
    file name            : /usr/local/vxWorks/T222/mv2700-asd1
    inet on ethernet (e) : xxx.xxx.xxx.xxx:fffffe00 
    inet on backplane (b): 
    host inet (h)        : xxx.xxx.xxx.xxx
    gateway inet (g)     : 
    user (u)             : <vx_username> 
    ftp password (pw) (blank = use rsh): <vx_password>  
    flags (f)            : 0x0
    target name (tn)     : iocxxx
    startup script (s)   : /home/server/USER/epics/xxx/iocBoot/iocxxx/st.cmd
    other (o)            : 
</pre>
</ul>

<P>See support/xxx/iocBoot/ioc*/bootParms for other processor types.  If you're
VME processor has mount access to an 'APSshare' NFS file server, you can specify
the 'file name', above, as "/APSshare/vw/T222/mv2700-asd1".



<P><h3><li>Fitting synApps to a particular set of hardware</h3>


<P>This happens in the user tree.  Generally, you must tell "EPICS" what
hardware is in your crate, and what addresses, interrupt vectors, etc. you have
set your hardware to use.  (See support/xxx/documentation/vme_address.html for a
list of suggested values.)  You also must specify which motors any slit,
table, monochromator, etc., control software is to use.  If you use serial or
GPIB, you must match port names to hardware devices, set serial-port parameters,
and specify GPIB addresses.  For any IndustryPack modules, you must specify the
IP carrier and slot into which you've loaded those modules.

<P>In a complete job of fitting synApps to an IOC's hardware, all of the
following files will be touched:
<dl>
<dt>xxx/iocBoot/ioc*/st.cmd
<dd>This is the ioc's startup script, and it loads the other .cmd files 

<P><dt>xxx/iocBoot/ioc*/*.cmd<br>
    xxx/iocBoot/ioc*/*.substitutions
<dd>Other command files that may or may not be invoked by st.cmd
	
<P><dt>xxx/iocBoot/ioc*/auto_positions.req<br>
    xxx/iocBoot/ioc*/auto_settings.req
<dd>specifies PV's to be saved/restored automatically

<P><dt>xxx/iocBoot/ioc*/saveData.req
<dd>identifies PV's used by the saveData software,  sscan records to be
	monitored for data, and PV's whose values are to be included in all
	scan-data files.

<P><dt>xxx/iocBoot/ioc*/bootParms
<dd>a copy of the boot parameters (in case the IOC processor
        crashes in a way that erases nonvolatile memory)
</dl>

<P><ul>
<li>xxx/iocBoot/ioc*/st.cmd

<P>This is the file run by the IOC at boot time.  It loads an executable built in
the IOC directory (e.g., xxx, or xxx.munch), sets parameters to configure that
software, makes calls to that software to configure it for a particular set of
hardware, and loads databases from synApps modules.  Mostly, it sources other
.cmd files that do these same things.

<P>This file, and the files it sources, are probably worth studying.  They are
reasonably well commented, and contain dbLoadRecords() commands for most of
the EPICS databases in synApps. 

<P><li>Motors

<P>To load more motors, add lines to the file xxx/iocBoot/ioc*/motor.substitutions.
For motors controlled by a VME board, edit vme.cmd to specify the hardware
address, etc.  For motors controlled through a serial connection, edit
serial.cmd.

<P>If you want the new motors to work with the 'AllStop' button ("xxx:allstop.VAL"
-- see the top-level medm display xxx.adl), load the database
$(MOTOR)/db/motorUtil.db, and run the command "motorUtilInit("xxx:")".

<P>If you want the IOC automatically to save positions and settings of the new
motors, and restore them when the crate reboots, add lines to the files
xxx/iocBoot/ioc*/auto_settings.req and xxx/iocBoot/ioc*/auto_positions.req.

<P><li>Slits

<P>To use a pair of motors to control a slit, search for "2slit.db" in
xxx/iocBoot/ioc*/st.cmd, and edit the dbLoadRecords() command you'll find
there.  The example in st.cmd loads two copies of 2slit.db intended for use as
the horizontal and vertical members of a four-jaw slit.  The medm displays
2slit*.adl and 4slit*.adl are involved in these applications.

<P>The slit database makes the following assumptions about the two motors
attached to the individual slit leaves:
<ul>
<li>Both of them have the same engineering units.
<li>Their .VAL fields are in the same coordinate system.  I.e., if the slit is
closed, both motors have the same value.
<li>The APS standard beamline coordinate system is used.  Positive Z is the beam
direction; positive Y is upward; positive X is outward from the storage ring.
So then, if I open a slit, one motor's .VAL field increases and the other's
decreases.
</ul>

<P>The 2slit.db database allows users to move either the slit virtual motors or
the actual motors, and it keeps all the readback values current regardless of
how the actual motors got moved or recalibrated. But it does not automatically
reset the slit *drive* values when the actual motors are used.  This must be
done manually, using the "SYNC" button on the 2slit.adl display.  Pressing this
button causes the database to read the actual motor drive values and set the
slit-drive values accordingly.

<P>To recalibrate slit positions, press the "Set" button, type in the current slit
position as you want it to be called, and press the "Use" button.  This
procedure uses the "Set" buttons of both motors the slit software talks to, and
the user/dial offsets of those motors actually implement the recalibration. 

<P>There is a new, experimental slit database in synApps which uses soft motor
records as the user/client interface.  This allows clients that know how to
control a motor also to control a slit, with some limitations.  We hope to use
soft motor records in front of other positioners (e.g. monochromators, optical
tables, insertion devices, and DAC channels) in the future.

<P><li>Optical tables
<P>Optical tables are controlled by a custom EPICS record (the "table" record),
used in the database table.db and controlled via medm displays table*.adl.

<P>Table virtual motors behave in much the same way as do slit virtual motors. 
However, the table software does not use user/dial offsets in the underlying
motor to implement recalibration (it can't, since it works through a nonlinear
transform).  Instead, the table maintains its own offsets for all of the six
coordinated motions it implements. Pressing the "Set" button causes new table
positions to modify the offsets instead of moving the table (which is exactly
the way motor and slit calibration works).  In addition to a "Sync" button,
which reads motor positions and calculates the table positions from them, the
table display has an "Init" button, which zeros all offsets before doing a
"sync" operation.  It also has a "Zero" button, which manipulates all the table
offsets to make the current table positions zero without moving or
recalibrating any motors.

<P><li>Monochromators
<P>Several varieties of crystal monochromators are supported in synApps: two
constant-offset "channel-cut" monochromators, a high-resolution double-crystal
monochromator, and a spherical-grating monochromator. Most are supported by
databases paired with State Notation Language (SNL) programs, and several medm
displays.  The EPICS databases kohzuSeq.db, SNL program kohzuCtl.st, and medm
displays kohzu*.adl (also kohzu*.gif) are involved in control of two varieties
of high-heat-load monochromators.  The EPICS database hrSeq.db, SNL program
hrCtl.st, and medm displays hSeq*.adl are involbed in control of the
high-resolution double-crystal monochromator.  The spherical grating
monochromator is supported by the database SGM.db and the displays SGM*.adl.

<P><li>Filters
<P>The APS standard user filters combine several motors and solenoids to control
the placement of filter material in the beam path.  The databases
filterMotor.db and filterLock.db, and the medm displays *filter*.adl are
involved in this application.

<P><li>Basic run-time programming
<P>Impromptu coordinated motions and other bits of run-time programming are
handled by what we call a "userCalc" (actually just a swait record with a nice
Medm interface) or a "userTransform" (actually just a transform record with a
nice medm interface).  We normally load ten of these into each EPICS processor,
and the users type in expressions to be evaluated, and link inputs and outputs,
as needed to glue existing objects together to do what they want done at the
moment.  Here are some examples of the tasks that have been accomplished with
userCalcs and userTransforms:

<ul>
<li>turn off hardware feedback control of a monochromator crystal when beam drops
below a user-specified level.  The userCalc monitored the EPICS PV that
contains the value of the positron beam-current, and drove a DAC channel (used
as a digital i/o bit) that enabled hardware feedback.

<li>support the ubiquitous theta/two-theta coordination by slaving the two-theta
motor's .VAL field to the theta motor's .VAL field.

<li>talk to a motor through a nonlinear transformation, e.g., energy-to-
Bragg-angle.

<li>close slow feedback loops -- e.g., to adjust a monochromator crystal to
suppress third-order diffraction through the high-heat-load monochromator.

<li>move multichannel-analyzer regions of interest automatically as the incident
beam energy changes.

<li>save and automatically subtract shutter-closed offsets from scaler data.
</ul>

<P><li>string-expression support
<P>Run-time programming involving strings and/or numbers can be done with
userStringCalcs, which resemble userCalcs closely, but differ in significant
details.  A package containing two stringCalcs and an 'asyn' record (called a
"deviceCmdReply") is also available for run-time programming of simple serial-
and GPIB-device support.

<P><li>array-expression support
<P>Run-time programming involving arrays and/or numbers can be done with
userArrayCalcs, which resemble userCalcs closely, but differ in significant
details.

<P><li>scan support <P>Scans of up to five dimensions are supported by the
standardScans.db database.  Scan data is written to disk by the saveData
program, whose user interface is contained in saveData.db.  The number of data
points per scan dimension is specified when standardScans.db is loaded, and is
limited to 2000, unless the environment variable EPICS_CA_MAX_ARRAY_BYTES is
specified.

<P>Note that loading saveData.db does not automatically cause scan data to be
written to disk.  You must also call the function saveData_Init(), specifying a
scan-configuration file (saveData.req) which tells saveData which sscan records
to monitor.

<P>Also note that initializing saveData is an all-or-nothing choice.  If you
initialize saveData, then <i>all</i> scans performed by sscan records named in
the configuration file must be written to disk.  If saveData cannot write a
file, it will prevent the next scan from completing.  (Scans performed by sscan
records that are <i>not</i> named in saveData.req are completely outside of this
restriction.  The data they accumulate is not written to disk by saveData, so
saveData is not involved in their operation.)

<P><li>sequence support
<P>Run-time programming of sequences is possible using the sseq record and related
medm displays yySseq.adl

<P><li>multiple-step measurement
<P>Up to four measurement steps involving positioners, detectors, and end
calculations (e.g., to support dichroism experiments) can be done with the
4step.db database and the related medm display, 4step.adl. The entire
measurement sequence can be involved in a scan by treating the 4step database
as you would treat the scaler or mca software.
</ul>

<P><h3><li>Running synApps</h3>

<ol>
<P><li>Boot parameters

<P>See xxx/iocBoot/ioc*/bootParms for sample boot parameters.

<P><li>MEDM

<P>See the MEDM Operator's Manual for detailed information on the special needs of
this X11/Motif program.  I'll assume those needs have been met.

<P>Edit the file xxx/start_epics_xxx to so it sets the environment variable
EPICS_APP to the directory that contains xxxApp.  If you plan to run MEDM on a
workstation that isn't on the same subnet as the IOC's, you'll need to
uncomment and edit the definition of the environment variable
EPICS_CA_ADDR_LIST.  In principle, you should be able to name only the
broadcast address for the subnet that contains the IOC's, but if this doesn't
work, you can put in the IP addresses of all the IOC's you want to connect
with, separated by spaces, as follows:

	setenv EPICS_CA_ADDR_LIST "164.54.53.126 164.54.53.127"

<P>If you want to use arrays larger than 16000 bytes (e.g., MCA spectra of more
than 4000 channels, or scans of more than 2000 data points), you must set the
environment variable EPICS_CA_MAX_ARRAY_BYTES, in *both* the IOC and
workstation, to the size of the largest array you plan to send over the
network, plus the size of the extra data channel access might be asked to
include with the array.  On a Unix system, for example, you might say

	setenv EPICS_CA_MAX_ARRAY_BYTES 64008

in the IOC's st.cmd file, you'd say

	putenv "EPICS_CA_MAX_ARRAY_BYTES=64008"

<P>To bring up the top-level medm display for synApps software, cd to xxx and type
"start_epics_xxx" (e.g., start_epics_1bma).  This script locates the
directories that might have medm-display files and includes them in the
environment variable EPICS_DISPLAY_PATH, cd's to xxxApp/op/adl, and runs MEDM
with the default top-level display file.

<P><li>autosave/restore

<P>You must give the crate write permission to xxx/iocBoot/ioc*/autosave so it can
write the files auto_positions.sav and auto_settings.sav there.  It's also
helpful to set the autosave directory's 'group' bit so that files the crate
writes will be owned by the owner of the directory instead of by
<vxworks_user>.  Normally, I do this:

    chmod a+w,g+s autosave

<P>To modify the list of PV's that are saved and restored, edit the files

   xxx/iocBoot/ioc*/auto_settings.req and
   xxx/iocBoot/ioc*/auto_positions.req

<P>The autosave software is started by the lines "create_monitor_set(..." in
xxx/iocBoot/ioc*/st.cmd.  The restore happens during iocInit as a result of
function calls inserted into initHooks.o, which is loaded by
xxx/iocBoot/ioc*/st.cmd.


<P><li>saveData

<P>saveData is a CA client that monitors sscan records and saves scan data to
files on as NFS-mounted disk.  The software is configured with the file
xxx/iocBoot/ioc*/saveData.req, which needs no special attention unless you want
to modify the list of EPICS PV's whose values are to be saved with every data
file.  To do this, look for the string "[extraPV]" in the file, and edit the
list of PV's immediately following that string.  If an entry in this list
contains only the PV name, saveData will describe the PV, in the data file,
using the .DESC field of the record that contains that PV.  If a string follows
the PV name, saveData will use the string instead.

</ol>
</ol>

<h2>The synApps utils directory</h2>
<P>The synApps support/utils directory contains a variety of executables
that may be useful in administering and/or using synApps.  Some of these tools are
probably peculiar to the way synApps is used at APS, and may not be of any use

<P><dl>
<dt>changePrefix, doSed
<dd>These are for the application developer's convenience in changing EPICS
prefixes in a user tree.  You must be in the top level of the user tree to run
changePrefix, and you should do a "gnumake clean uninstall" before running it.

<P>Example of use:
<pre>
    cd $(SYNAPPS)/ioc/1bm
    changePrefix xxx 1bma
</pre>

<dt>copyAdl
<dd>
Look through synApps for .adl files, and copy them all to a specified directory

<P>Example of use:
<pre>
    copyAdl $SYNAPPS/support adl_files
</pre>

<dt>convertIocFiles.py

<dd>This file, and its associates, are intended to help convert an IOC directory
from one version of EPICS to another, by collecting data from an existing IOC
directory, and attempting to correctly edit files in a new IOC directory. See
support/utils/HowToUse_convertIocFiles.txt for more information on this program.

<P><dt>mdautils-src.tar.gz <dd> This tar file contains utility programs for
using data files written by the sscan module's "saveData" program.  These
programs were written by Dohn Arms, and contributed to synApps.

<P><dt>mdaExplorer
<dd>This wxPython program displays the content of MDA files, and directories of
MDA files.  (An MDA file is the scan-data file produced by the synApps sscan
module's saveData software during a scan.)


<P><dt>mdaPythonUtils
<dd>A collection of python programs that read, write, modify, and translate
MDA files.

<P><dt>snapDb
<dd>A wxPython rapid development tool for EPICS databases and MEDM display
files.  This program supports the use of EPICS' run-time programmability
to prototype a EPICS databases, using records loaded into an IOC.  It's
particularly useful for synApps "userCalcs", a collection of various
record types intended for end users to program at run time. 
</dl>


</ol>

<hr>
<address> 
    Suggestions and Comments to: <br> 
    <a href="mailto:mooney@aps.anl.gov">Tim Mooney </a>:
    (mooney@aps.anl.gov) <br> 
	Beamline Controls & Data Acquisition Group<br>
	Advanced Photon Source, Argonne National Laboratory<br>
    Last modified: February 20, 2009
</address> 
</body>
</html>
