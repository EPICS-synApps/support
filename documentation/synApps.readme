	synApps 5.4

synApps is a collection of custom EPICS software (source code, EPICS databases,
client scripts, MEDM display files, executables, etc.) intended to support most
of the requirements of an x-ray laboratory or synchrotron-radiation (SR)
experiment station.  Several instances of this application can work together to
support an entire SR beamline.  synApps is also intended to underly additional
software that may be station or beamline specific.

This release of synApps is compatible with EPICS release 3.14.10, Tornado 2.2,
and the following EPICS modules/versions produced and maintained by other
members of the EPICS collaboration:

allenBradley v2-1     for communicating with Allen Bradley PLC's (ANL)
ipac         v2-10    required for IndustryPack support (ANL)
asyn         v4-10    required by many modules (ANL)
seq          v2-0-12  for SNL programs in synApps (SLAC)
stream       v2-4     configurable device support for message-based devices
vxStats      v1-7-2g  vxWorks statistics modified by us (SNS)

Previous versions of synApps included and relied on the genSub module.  In EPICS
3.14.10, a replacement for the genSub record, called the asub record, is
included in base, and synApps has been modified to use it instead of the genSub
record.

For convenience, this distribution includes the module versions listed above,
in place and ready to build, with minor modifications to build files.  A few of
the modules have suffered more substantial modifications to fix problems, add
MEDM displays, etc.

Here's a list of the modules and directories that actually are part of synApps:

areaDetector  support for area (2-D) detectors, including CCDs, pixel array
              detectors, and online imaging plates.  This module replaces the
			  ccd and pilatus modules, which are nevertheless included in this
			  version of synApps.
autosave      save-restore
busy          the busy record, previously supplied by the sscan module
calc          run-time expression evaluation
camac         CAMAC support
ccd           scientific CCD detectors, including Bruker, MAR, and Roper
configure     (directory) build files, including the top-level make file
dac128V       IndustryPack DAC
delaygen      delay generators
dxp           XIA's DXP digital signal processor
ebrick        support and sample application for low-cost PC-104 and uCDIMM based IOC
ip            various serial devices
ip330         IndustryPack ADC
ipUnidig      IndustryPack digital I/O
love          Love controllers
mca           multichannel analyzers
modbus        support for ModBus-protocol devices over TCP, serial RTU, and
              serial ASCII links
motor         motors
optics        optical table, monochromators, slits, etc.
pilatus       supports Dectris pixel-array detector
quadEM        4-channel electrometer
sscan         sscan record and related software
std           misc EPICS software
stream        Dirk Zimoch's streamDevice, in a module-flavored wrapper
utils         (directory) miscellaneous tools
vac           supports vacuum controllers
vme           vme-specific support
xxx           sample user-application directory

See configure/RELEASE for a complete set of compatible module versions. In
most cases, there is some negative consequence of using a different version
than the one specified in configure/RELEASE.

synApps includes software developed by the Beamline Controls & Data Acquisition
and the Accelerator Controls groups of the Advanced Photon Source (APS); by
developers in APS Collaborative Access Teams -- notably, Mark Rivers (CARS-CAT);
and by developers in the EPICS collaboration outside of the APS -- notably,
those at the Swiss Light Source/Paul Scherrer Institut, the Diamond Light
Source, the National Synchrotron Light Source, the Australian Light Source, and
the Canadian Light Source.

Aside from EPICS databases, SNL (State Notation Language) programs, and the
like, synApps contains the following code:

Record support
    aCalcout   calcout record extended to handle array expressions
    busy       utility record: calls recGblFwdLink only when its
               VAL field is zero, allowing CA clients, and asyn drivers to
			   participate in EPICS putNotify (ca_put_callback()) operations.
    camac      user/database interface to CAMAC bus
               Execute a CAMAC CNAF command
    dxp	       XIA's DXP digital signal processor
               Set/read signal-processor parameters
    epid       Extended version of the EPICS PID record, for
               implementing feedback loops
    mca        support for multichannel analyzers, and some other
               array-valued detectors
    motor      stepper and servo motors, "soft" motor
    sCalcout   calcout record extended to handle string expressions,
               links, and values.
    scaler     scaler bank
    sscan      Replaces the scan record (Ned Arnold/APS) in base.
               This version uses a modified version of recDynLlib
               that supports dbNotify command completion.  It uses
               ca_put_callback to do puts, instead of ca_put.
    scanparm   scan parameters for use with the scan record
    sseq       string-sequence record.  This is a modified version of
               the seq record in base.  This version can link to/from
               either string or numeric PVs, and it can use
               dbCaPutLinkCallback to wait for completion of the
               execution started by one link before going on to the
               next.
    swait      replaces the wait record in base.
               This version uses a modified version of recDynLlib
               that supports dbNotify command completion.  It uses
               ca_put_callback to do puts, instead of ca_put.
    table      6-degree-of-freedom optical table
    transform  like an array of calc records, with output links
    vme        generic vme record (Mark Rivers/APS/CARS-CAT)
    timestamp  (written by Stephanie Allison/SLAC) Needed by the vxStats
               module, but apparently not available in a published module.

Device/driver support in or included with synApps
record     bus-type	 codename                     username
----------------------------------------------------------
acalcout   CONSTANT  devaCalcoutSoft              Soft Channel")
ai         AB_IO     devAiAb1771Ife               AB-1771IFE")
ai         AB_IO     devAiAb1771Ife0to5V          AB-1771IFE-0to5Volt")
ai         AB_IO     devAiAb1771IfeMa             AB-1771IFE-4to20MA")
ai         AB_IO     devAiAb1771IfeSe             AB-1771IFE-SE")
ai         AB_IO     devAiAb1771Il                AB-1771IL-Analog In")
ai         AB_IO     devAiAb1771IrCopper          AB-1771RTD-Copper")
ai         AB_IO     devAiAb1771IrPlatinum        AB-1771RTD-Platinum")
ai         AB_IO     devAiAb1771Ixe               AB-1771IXE-Millivolt In")
ai         AB_IO     devAiAbSlcDcm                AB-SLC500DCM")
ai         AB_IO     devAiAbSlcDcmSigned          AB-SLC500DCM-Signed")
ai         BBGPIB_IO devAiAX301                   PZT Bug")
ai         CONSTANT  devAiTodSeconds              Sec Past Epoch")
ai         GPIB_IO   devAiGP307Gpib               Vg307 GPIB Instrument")
ai         GPIB_IO   devAiHeidAWE1024             Heidenhein Encoder")
ai         GPIB_IO   devAiKeithleyDMM199          KeithleyDMM199")
ai         GPIB_IO   devGpib                      GPIB init/report")
ai         INST_IO   asynAiFloat64                asynFloat64")
ai         INST_IO   asynAiFloat64Average         asynFloat64Average")
ai         INST_IO   asynAiInt32                  asynInt32")
ai         INST_IO   asynAiInt32Average           asynInt32Average")
ai         INST_IO   devAiAb1791                  Allen Bradley 1791")
ai         INST_IO   devAiAbDcm                   Ab Dcm")
ai         INST_IO   devAiClusts                  VX stats clusts")
ai         INST_IO   devAiHeidND261               asyn ai HeidND261")
ai         INST_IO   devAiMKS                     HPS SensaVac 937")
ai         INST_IO   devAiMPC                     asyn MPC")
ai         INST_IO   devAiStats                   VX stats")
ai         INST_IO   devAiStrParm                 asyn ai stringParm")
ai         INST_IO   devAiTPG261                  asyn TPG261")
ai         INST_IO   devAiTelevac                 asyn Televac")
ai         INST_IO   devInterfaceAI1              InterfaceAI1")
ai         VME_IO    devAiA32Vme                  Generic A32 VME")
ai         VME_IO    devAiAvmeMRD                 devAvmeMRD")
ai         VME_IO    devAiBunchClkGen             APS Bunch Clock")
ai         VME_IO    devAiVaroc                   ESRF Varoc SSI Encoder Iface")
ai         VME_IO    devIK320Ai                   Heidenhain IK320")
ai         VME_IO    devIK320GroupAi              Heidenhain IK320 Group")
ao         AB_IO     devAoAb1771Ofe               AB-1771OFE")
ao         AB_IO     devAoAbSlcDcm                AB-SLC500DCM")
ao         BBGPIB_IO devAoAX301                   PZT Bug")
ao         GPIB_IO   devAoHeidAWE1024             Heidenhein Encoder")
ao         GPIB_IO   devAoKeithleyDMM199          KeithleyDMM199")
ao         INST_IO   asynAoFloat64                asynFloat64")
ao         INST_IO   asynAoInt32                  asynInt32")
ao         INST_IO   devAoAb1791                  Allen Bradley 1791")
ao         INST_IO   devAoAbDcm                   Ab Dcm")
ao         INST_IO   devAoEurotherm               asyn ao Eurotherm")
ao         INST_IO   devAoMPC                     asyn MPC")
ao         INST_IO   devAoStats                   VX stats")
ao         INST_IO   devAoStrParm                 asyn ao stringParm")
ao         INST_IO   devAoTPG261                  asyn TPG261")
ao         INST_IO   devInterfaceAO1              InterfaceAO1")
ao         VME_IO    devAoA32Vme                  Generic A32 VME")
ao         VME_IO    devAoAvme9210                AVME-9210")
ao         VME_IO    devAoBunchClkGen             APS Bunch Clock")
ao         VME_IO    devAoVMI4116                 VMIVME-4116")
asyn       INST_IO   asynRecordDevice             asynRecordDevice")
bi         AB_IO     devBiAb                      AB-Binary Input")
bi         AB_IO     devBiAb16                    AB-16 bit BI")
bi         AB_IO     devBiAb32                    AB-32 bit BI")
bi         GPIB_IO   devBiGP307Gpib               Vg307 GPIB Instrument")
bi         GPIB_IO   devBiHeidAWE1024             Heidenhein Encoder")
bi         GPIB_IO   devBiKeithleyDMM199          KeithleyDMM199")
bi         INST_IO   asynBiInt32                  asynInt32")
bi         INST_IO   asynBiUInt32Digital          asynUInt32Digital")
bi         INST_IO   devBiAbDcm                   Ab Dcm")
bi         INST_IO   devBiMPC                     asyn MPC")
bi         INST_IO   devBiStrParm                 asyn bi stringParm")
bi         INST_IO   devBiTPG261                  asyn TPG261")
bi         INST_IO   devBiTelevac                 asyn Televac")
bi         VME_IO    devBiA32Vme                  Generic A32 VME")
bi         VME_IO    devBiAvme9440                AVME9440 I")
bi         VME_IO    devBiAvmeMRD                 devAvmeMRD")
bi         VME_IO    devBiBunchClkGen             APS Bunch Clock")
bi         VME_IO    devBiHP10895LaserAxis        HP interferometer")
bo         AB_IO     devBoAb                      AB-Binary Output")
bo         AB_IO     devBoAb16                    AB-16 bit BO")
bo         AB_IO     devBoAb32                    AB-32 bit BO")
bo         BBGPIB_IO devBoAX301                   PZT Bug")
bo         GPIB_IO   devBoGP307Gpib               Vg307 GPIB Instrument")
bo         GPIB_IO   devBoHeidAWE1024             Heidenhein Encoder")
bo         GPIB_IO   devBoKeithleyDMM199          KeithleyDMM199")
bo         INST_IO   asynBoInt32                  asynInt32")
bo         INST_IO   asynBoUInt32Digital          asynUInt32Digital")
bo         INST_IO   devBoAbDcm                   Ab Dcm")
bo         INST_IO   devBoMPC                     asyn MPC")
bo         INST_IO   devBoStrParm                 asyn bo stringParm")
bo         INST_IO   devBoTPG261                  asyn TPG261")
bo         VME_IO    devBoA32Vme                  Generic A32 VME")
bo         VME_IO    devBoAvme9440                AVME9440 O")
bo         VME_IO    devBoAvmeMRD                 devAvmeMRD")
bo         VME_IO    devBoBunchClkGen             APS Bunch Clock")
bo         VME_IO    devBoHP10895LaserAxis        HP interferometer")
busy       CONSTANT  devBusySoft                  Soft Channel")
busy       INST_IO   asynBusyInt32                asynInt32")
epid       CONSTANT  devEpidSoft                  Soft Channel")
epid       INST_IO   devEpidFast                  Fast Epid")
longin     AB_IO     devLiAbSlcDcm                AB-SLC500DCM")
longin     GPIB_IO   devLiHeidAWE1024             Heidenhein Encoder")
longin     GPIB_IO   devLiKeithleyDMM199          KeithleyDMM199")
longin     INST_IO   asynLiInt32                  asynInt32")
longin     INST_IO   asynLiUInt32Digital          asynUInt32Digital")
longin     INST_IO   devLiAbDcm                   Ab Dcm")
longin     INST_IO   devLiStrParm                 asyn li stringParm")
longin     VME_IO    devLiA32Vme                  Generic A32 VME")
longin     VME_IO    devLiAvmeMRD                 devAvmeMRD")
longin     VME_IO    devLiHP10895LaserAxis        HP interferometer")
longout    AB_IO     devLoAbSlcDcm                AB-SLC500DCM")
longout    BBGPIB_IO devLoAX301                   PZT Bug")
longout    GPIB_IO   devLoHeidAWE1024             Heidenhein Encoder")
longout    GPIB_IO   devLoKeithleyDMM199          KeithleyDMM199")
longout    INST_IO   asynLoInt32                  asynInt32")
longout    INST_IO   asynLoUInt32Digital          asynUInt32Digital")
longout    INST_IO   devLoAbDcm                   Ab Dcm")
longout    INST_IO   devLoStrParm                 asyn lo stringParm")
longout    VME_IO    devLoA32Vme                  Generic A32 VME")
longout    VME_IO    devLoHP10895LaserAxis        HP interferometer")
mbbi       AB_IO     devMbbiAb                    AB-Binary Input")
mbbi       AB_IO     devMbbiAb16                  AB-16 bit BI")
mbbi       AB_IO     devMbbiAb32                  AB-32 bit BI")
mbbi       AB_IO     devMbbiAbAdapterStat         AB-Adapter Status")
mbbi       AB_IO     devMbbiAbCardStat            AB-Card Status")
mbbi       GPIB_IO   devMbbiHeidAWE1024           Heidenhein Encoder")
mbbi       GPIB_IO   devMbbiKeithleyDMM199        KeithleyDMM199")
mbbi       INST_IO   asynMbbiInt32                asynInt32")
mbbi       INST_IO   asynMbbiUInt32Digital        asynUInt32Digital")
mbbi       INST_IO   devMbbiAbDcm                 Ab Dcm")
mbbi       INST_IO   devMbbiTPG261                asyn TPG261")
mbbi       VME_IO    devMbbiA32Vme                Generic A32 VME")
mbbi       VME_IO    devMbbiAvme9440              AVME9440 I")
mbbi       VME_IO    devMbbiAvmeMRD               devAvmeMRD")
mbbi       VME_IO    devMbbiHP10895LaserAxis      HP interferometer")
mbbiDirect AB_IO     devMbbiDirectAb              AB-Binary Input")
mbbiDirect AB_IO     devMbbiDirectAb16            AB-16 bit BI")
mbbiDirect AB_IO     devMbbiDirectAb32            AB-32 bit BI")
mbbiDirect INST_IO   asynMbbiDirectUInt32Digital  asynUInt32Digital")
mbbo       AB_IO     devMbboAb                    AB-Binary Output")
mbbo       AB_IO     devMbboAb16                  AB-16 bit BO")
mbbo       AB_IO     devMbboAb32                  AB-32 bit BO")
mbbo       GPIB_IO   devMbboHeidAWE1024           Heidenhein Encoder")
mbbo       GPIB_IO   devMbboKeithleyDMM199        KeithleyDMM199")
mbbo       INST_IO   asynMbboInt32                asynInt32")
mbbo       INST_IO   asynMbboUInt32Digital        asynUInt32Digital")
mbbo       INST_IO   devMbboAbDcm                 Ab Dcm")
mbbo       INST_IO   devMbboMPC                   asyn MPC")
mbbo       INST_IO   devMbboTPG261                asyn TPG261")
mbbo       VME_IO    devIK320Dir                  Heidenhain IK320 Sign")
mbbo       VME_IO    devIK320Funct                Heidenhain IK320 Command")
mbbo       VME_IO    devIK320ModeX3               Heidenhain IK320 X3 Mode")
mbbo       VME_IO    devMbboA32Vme                Generic A32 VME")
mbbo       VME_IO    devMbboAvme9440              AVME9440 O")
mbbo       VME_IO    devMbboHP10895LaserAxis      HP interferometer")
mbboDirect AB_IO     devMbboDirectAb              AB-Binary Output")
mbboDirect AB_IO     devMbboDirectAb16            AB-16 bit BO")
mbboDirect AB_IO     devMbboDirectAb32            AB-32 bit BO")
mbboDirect INST_IO   asynMbboDirectUInt32Digital  asynUInt32Digital")
mca        CONSTANT  devMCA_soft                  Soft Channel")
mca        INST_IO   devMcaAsyn                   asynMCA")
mca        VME_IO    devSTR7201                   Struck STR7201 MCS")
motor      CONSTANT  devMotorSoft                 Soft Channel")
motor      INST_IO   devMotorAsyn                 asynMotor")
motor      VME_IO    devE500                      E500")
motor      VME_IO    devESP300                    ESP300")
motor      VME_IO    devIM483PL                   IM483PL")
motor      VME_IO    devIM483SM                   IM483SM")
motor      VME_IO    devMAXv                      OMS MAXv")
motor      VME_IO    devMCB4B                     ACS MCB-4B")
motor      VME_IO    devMCDC2805                  MCDC2805")
motor      VME_IO    devMDrive                    MDrive")
motor      VME_IO    devMM3000                    MM3000")
motor      VME_IO    devMM4000                    MM4000")
motor      VME_IO    devMVP2001                   MVP2001")
motor      VME_IO    devMicos                     Micos MoCo")
motor      VME_IO    devMotorSim                  Motor Simulation")
motor      VME_IO    devOMS                       OMS VME8/44")
motor      VME_IO    devOms58                     OMS VME58")
motor      VME_IO    devOmsPC68                   OMS PC68/78")
motor      VME_IO    devPC6K                      PC6K")
motor      VME_IO    devPIC630                    PI C630")
motor      VME_IO    devPIC662                    PIC662")
motor      VME_IO    devPIC844                    PIC844")
motor      VME_IO    devPIC848                    PIC848")
motor      VME_IO    devPIC862                    PIC862")
motor      VME_IO    devPIE516                    PIE516")
motor      VME_IO    devPIE710                    PIE710")
motor      VME_IO    devPIE816                    PIE816")
motor      VME_IO    devPM304                     Mclennan PM304")
motor      VME_IO    devPM500                     PM500")
motor      VME_IO    devPMNC87xx                  PMNC87xx")
motor      VME_IO    devPmac                      PMAC")
scalcout   CONSTANT  devsCalcoutSoft              Soft Channel")
scaler     INST_IO   devScalerAsyn                Asyn Scaler")
scaler     VME_IO    devScaler                    Joerger VSC8/16")
scaler     VME_IO    devScalerCamac               CAMAC scaler")
scaler     VME_IO    devScalerSTR7201             Struck STR7201 Scaler")
scaler     VME_IO    devScaler_VS                 Joerger VS")
stringin   CONSTANT  devSiTodString               Time of Day")
stringin   GPIB_IO   devSiGP307Gpib               Vg307 GPIB Instrument")
stringin   GPIB_IO   devSiHeidAWE1024             Heidenhein Encoder")
stringin   GPIB_IO   devSiKeithleyDMM199          KeithleyDMM199")
stringin   INST_IO   asynSiOctetCmdResponse       asynOctetCmdResponse")
stringin   INST_IO   asynSiOctetRead              asynOctetRead")
stringin   INST_IO   asynSiOctetWriteRead         asynOctetWriteRead")
stringin   INST_IO   devSiMPC                     asyn MPC")
stringin   INST_IO   devSiSeq                     Sequencer Internals")
stringin   INST_IO   devSiStrParm                 asyn si stringParm")
stringin   INST_IO   devSiTPG261                  asyn TPG261")
stringin   INST_IO   devStringinStats             VX stats")
stringout  GPIB_IO   devSoHeidAWE1024             Heidenhein Encoder")
stringout  GPIB_IO   devSoKeithleyDMM199          KeithleyDMM199")
stringout  INST_IO   asynSoOctetWrite             asynOctetWrite")
stringout  INST_IO   devSoEurotherm               asyn so Eurotherm")
stringout  INST_IO   devSoMPC                     asyn MPC")
stringout  INST_IO   devSoStrParm                 asyn so stringParm")
stringout  VME_IO    devIK320Parm                 Heidenhain IK320 Parameter")
swait      CONSTANT  devSWaitIoEvent              Soft Channel")
waveform   INST_IO   asynFloat32ArrayWfIn         asynFloat32ArrayIn")
waveform   INST_IO   asynFloat32ArrayWfOut        asynFloat32ArrayOut")
waveform   INST_IO   asynFloat64ArrayWfIn         asynFloat64ArrayIn")
waveform   INST_IO   asynFloat64ArrayWfOut        asynFloat64ArrayOut")
waveform   INST_IO   asynInt16ArrayWfIn           asynInt16ArrayIn")
waveform   INST_IO   asynInt16ArrayWfOut          asynInt16ArrayOut")
waveform   INST_IO   asynInt32ArrayWfIn           asynInt32ArrayIn")
waveform   INST_IO   asynInt32ArrayWfOut          asynInt32ArrayOut")
waveform   INST_IO   asynInt8ArrayWfIn            asynInt8ArrayIn")
waveform   INST_IO   asynInt8ArrayWfOut           asynInt8ArrayOut")
waveform   INST_IO   asynWfOctetCmdResponse       asynOctetCmdResponse")
waveform   INST_IO   asynWfOctetRead              asynOctetRead")
waveform   INST_IO   asynWfOctetWrite             asynOctetWrite")
waveform   INST_IO   asynWfOctetWriteRead         asynOctetWriteRead")
waveform   VME_IO    devWfBunchClkGen             APS Bunch Clock")



Miscellaneous C code

	aCalcPostfix, aCalcPerform
	sCalcPostfix, sCalcPerform
		Support for run-time expression evaluation
	recDynLink
		Backward compatible extension of the dynamic-link software
		previously in EPICS base.  (New code should probably use
		dbCaPutlinkCallback(), instead of recDynLink.)
	save_restore, dbrestore
		Automatic parameter save and boot-time restore.
	saveData
		Saves scan data to files on an NFS-mounted disk.
	
Documentation

	In addition to this top-level documentation, synApps modules have their
	own documentation directories, and the xxx module contains examples of
	how most of the software is loaded and run. Some modules have their own
	example iocBoot directories.


How to use synApps
------------------

Although synApps is distributed as a single 'support' directory, it's normally
used as a two-part system: the 'support' tree, and a 'user' tree.  The support
tree can be installed on a read-only file system, along with EPICS base and
other modules, and used from there by the user tree, which begins as a copy of
the module 'support/xxx', and is customized/extended by the end user to
particular applications and sets of hardware.  To support several applications,
you might create several user trees, each supporting several ioc's, and link
all of those trees to the support tree.  (If you haven't run into the term
'ioc' yet, it stands for Input/Output Controller.  Initially, this was a VME
crate with a processor running EPICS under the VxWorks operating system, but
beginning with EPICS 3.14, an ioc can also be a set of tasks on a workstation
running Linux, Windows, Solaris, RTEMS, Mac OS, and probably other operating systems.)
Here's what a complete installation might look like (much detail omitted) with
all the files you will have to edit before you can build or boot an ioc:

support/
	Makefile                            <-- EDIT to build
	Makefile.win32-x86                  <-- EDIT to build for WIN32
	all_adl/
    allenBradley/
	areaDetector/
    asyn/
	busy/
    calc/
    camac/
    ccd/
    configure/
        CONFIG_SITE                     <-- EDIT to build
        RELEASE                         <-- EDIT to build
		RELEASE.win32-x86               <-- EDIT to build for WIN32
        ...
    dac128V/
    delaygen/
    documentation/
    dxp/
	ebrick/
    ip/
    ip330/
    ipUnidig/
    ipac/
		drvIpac/drvIpac.dbd             <-- EDIT to build
    love/
    mca/
	modbus/
    motor/
        motorApp/
	    Makefile                        <-- EDIT to build
    optics/
	pilatus/
    quadEM/
    seq/
    sscan/
    std/
    stream/
    utils/
	vac/
    vme/
    vxStats/
    xxx/

ioc/
    1bm/
        Makefile
        bin/
        configure/
		    RELEASE                     <-- EDIT to build
		    RELEASE.win32-x86           <-- EDIT to build for WIN32
        dbd/
        iocBoot/
            Makefile
            nfsCommands
            ioc1bma/
                Makefile
		        camac.cmd
		        canberra_1.cmd
		        canberra_13.cmd
		        canberra_3.cmd
		        dac128V.cmd
		        dxp_16.cmd
		        industryPack.cmd
		        ip330.cmd
		        ipUnidig.cmd
		        quadEM.cmd
		        save_restore.cmd
		        serial.cmd
		        vme.cmd
		        st.cmd
		        basic_motor.substitutions
		        canberra_13.substitutions
		        canberra_3.substitutions
		        dac128V.substitutions
		        dxp_16.substitutions
		        ip330Scan.substitutions
		        ipUnidig.substitutions
		        motor.substitutions
		        picMot.substitutions
		        pid_fast.substitutions
		        pid_slow.substitutions
		        quadEM_pid.substitutions
		        scanParms.substitutions
		        vxStats.substitutions
                auto_positions.req 
                auto_settings.req
                autosave/
                cdCommands or envPaths
                saveData.req 
            ioc1bmb/
                <much like ioc1bma>
        release.pl
		setup_epics_common
        start_epics_1bma
        start_epics_1bmb
        1bmaApp/
        1bmbApp/

    1id/
        <much like 1bm>
    ...


As shown above, the following files can be edited to modify the way the
synApps support tree is built:

support/Makefile
    comment out any modules you don't want to build

support/configure/RELEASE
	edit the definitions of EPICS_BASE and SUPPORT with the correct paths to
	these directories on your system.  Note that you should run "make release"
	in the support directory after modifying this file, to propagate the changes
	down to the modules named in support/Makefile.

support/configure/CONFIG_SITE
	Edit to set the following variables, which control what will be built:
	The supported values for these variables are YES and NO.

	LINUX_USB_INSTALLED
		This controls the build of the dxp module.  If usb is not installed
		for developers, then parts of dxp/dxpApp/handelSrc will not be built,
		and the example application executable, dxpApp, will not be built, so
		dxp/iocBoot cannot be used.

	LINUX_NET_INSTALLED
		This controls the build of the mca module, specifically, support for
		the Canberra AIM hardware.

	LINUX_TIFF_INSTALLED
		This controls the build of the areaDetector module, and is understood
		to indicate whether libtiff.a, libjpeg.a, and libz.a are all
		installed.  If they are not installed, areaDetector will not build
		the following directories that requires them: prosilicaSrc, pilatusSrc,
		and marCCDSrc.

ipac/<version>/drvIpac/drvIpac.dbd
	uncomment registrar() commands for IndustryPack carriers you plan to use.

motor/<version>/motorApp/Makefile
	comment or uncomment to select the motor support you want to build.

The following files must be edited in a user tree

ioc/<appname>/configure/RELEASE
ioc/<appname>/configure/RELEASE.win32-x86 (WIN32 only)
	edit the definition of SUPPORT with the correct path to the support tree


0) System configuration
=======================

Before building synApps, you should ensure that your system has the
libraries, header files, etc. required to build the modules you want
to build.  Here's the list:

Linux:
------
libtiff.a (areaDetector)
libjpeg.a (areaDetector)
libz.a    (areaDetector)
libusb.a  (dxp)

Cygwin:
-------
  <li>base
    <ul>
        <li>All default components
    </ul>
  <li>devel
    <ul> 
      <li>gcc-core
      <li>gcc-g++
      <li>libncurses-devel
      <li>make
      <li>readline
    </ul>
  <li>interpreters
    <ul>
      <li>perl
    </ul>
  <li>libs
    <ul>
      <li>ncurses
      <li>sunrpc
    </ul>


DLPORTIO (dxp)

Windows:
--------
DLPORTIO (dxp)

LEFT OFF HERE

1) Building and configuring the support tree
============================================

If you have a built copy of EPICS base 3.14.10 or later, then building synApps
should be very simple:

1) Edit support/Makefile, support/configure/RELEASE, and
   support/configure/CONFIG_SITE, as noted above.

2) Edit ipac/<version>/drvIpac/drvIpac.dbd, and
   motor/<version>/motorApp/Makefile, as noted above

3) Set the environment variable EPICS_HOST_ARCH to the architecture (and
   compiler, if there is a choice) on which you are building. I used
   solaris-sparc, linux-x86, and cygwin-x86.

4) In support, run "make release".

5) In support, run make.  (You should be able to use "make -j" to build
   synApps much more quickly than it has previously built.)

You should use the same GNU Make executable that was used to build EPICS
base.  You may need $(EPICS_BASE)/bin/<arch> in your path, and you may need
$(EPICS_BASE)/lib/<arch> in LD_LIBRARY_PATH.

When executed in the support directory, "make release" will go to all
of the modules support/Makefile knows about and edit the configure/RELEASE
files in those modules so that they all build from the same versions of EPICS
base and other known modules.

2) Building and configuring a user tree
========================================

Once synApps' support directory has built without errors, the xxx module will
have been configured and tested so that you can use it to build a user tree to
support your iocs.  (I.e., xxx/configure/RELEASE will have correct, absolute
paths to base and synApps.)  Clean and uninstall xxx, and tar a copy of the
directory for use as a template.  To use the template, untar it, cd to its
top-level directory and run utils/changePrefix to change the PV-name prefix from
xxx to whatever you want.  (Note you must have support/utils in your command
path, or you could copy utils/changePrefix and utils/doSed to a directory that
is in your command path.  Note that changePrefix is synApps-version specific.)

Here's what I do:

    # Do once when synApps is built:
    cd $(SYNAPPS)/support/xxx
    setenv EPICS_HOST_ARCH <host architecture>
    gnumake clean uninstall
    tar cvf ../xxx.tar *

    # Do whenever a new user tree ('1bm', in this example) is needed:
    cd $(SYNAPPS)/ioc
    mkdir 1bm
    cd 1bm
    tar xf $(SYNAPPS)/support/xxx.tar
    changePrefix xxx 1bma
	mv iocBoot/iocvxWorks iocBoot/ioc1bma
    edit iocBoot/ioc1bma/Makefile to specify the ioc processor type
    gnumake

To put a second application, 1bmb, into 1bm, I run the following commands:

    cd $(SYNAPPS)/ioc
    mkdir temp
    cd temp
    tar xf $(SYNAPPS)/support/xxx.tar
    changePrefix xxx 1bmb
	mv iocBoot/iocvxWorks iocBoot/ioc1bmb
    edit iocBoot/ioc1bmb/Makefile to specify the ioc processor type
    cd $(SYNAPPS)/ioc
    mv temp/1bmbApp/start_epics_1bmb 1bm
    mv temp/1bmbApp 1bm
    mv temp/iocBoot/ioc1bmb 1bm/iocBoot
    rm -rf temp
    cd 1bm
    gnumake

Edit the files above to agree with your hardware, to load the databases you
want, etc., set up the ioc processor's parameters to load from the software
just configured, and boot the crate.  If you don't know how to do this, read
on.


3) Setting up the ioc (vxWorks)
======================================================================

Ensure that $(EPICS_BASE)/bin/<arch>/caRepeater gets run when your
workstation boots.  If you have no way of doing this, you can run it manually
or put the command in your .login file.

Setup your host system to work with the EPICS processor.  See the "VxWorks
Programmer's Guide" if you have a copy.  Here's what we do (on a Sun
workstation):

    Add a user named <vx_username> with the password <vx_password>.
    The user has nothing in its home directory, and very few priviledges.

    Connect an ethernet cable to the processor.

    Setup the workstation to use a serial port at 9600 baud.
    Connect a serial cable from the workstation to the VME
    processor's "Console" port.

    Start up an "xterm" on the workstation and type
    cu -lttya
    (On some workstations we must type "cu -lcua/a".)
    This gets the xterm communicating with the crate processor.

    Turn the crate on.  The crate processor says "Press any key to
    stop auto-boot..." and a number counting down from 7.  Pressing
    a key gets the prompt "[VxWorks Boot]:"

    Type "p" to see the current boot parameters,  type "c" to
    change them.  Here are sample boot parameters 

    boot device          : dc 
    processor number     : 0 
    host name            : <server> 
    file name            : /usr/local/vxWorks/T222/mv2700-asd1
    inet on ethernet (e) : xxx.xxx.xxx.xxx:fffffe00 
    inet on backplane (b): 
    host inet (h)        : xxx.xxx.xxx.xxx
    gateway inet (g)     : 
    user (u)             : <vx_username> 
    ftp password (pw) (blank = use rsh): <vx_password>  
    flags (f)            : 0x0
    target name (tn)     : iocxxx
    startup script (s)   : /home/server/USER/epics/xxx/iocBoot/iocxxx/st.cmd
    other (o)            : 
	
See support/xxx/iocBoot/ioc*/bootParms for other processor types.  If you're
VME processor has mount access to an 'APSshare' NFS file server, you can specify
the 'file name', above, as "/APSshare/vw/T222/mv2700-asd1".



4) Fitting synApps to a particular set of hardware
======================================================

This happens in the user tree.  Generally, you must tell "EPICS" what hardware
is in your crate, and what addresses, interrupt vectors, etc. you have set your
hardware to use.  You also must specify which motors any slit, table,
monochromator, etc., control software is to use.  If you use serial or GPIB, you
must match port names to hardware devices, set serial-port parameters, and
specify GPIB addresses.  For any IndustryPack modules, you must specify the IP
carrier and slot into which you've loaded those modules.

In a complete job of fitting synApps to an ioc's hardware, all of the
following files will be touched:

    xxx/iocBoot/ioc*/st.cmd
	This is the ioc's startup script, and it loads the other .cmd files 

    xxx/iocBoot/ioc*/*.cmd
    xxx/iocBoot/ioc*/*.substitutions
		
    xxx/iocBoot/ioc*/auto_positions.req
    xxx/iocBoot/ioc*/auto_settings.req
        specifies PV's to be saved/restored automatically

    xxx/iocBoot/ioc*/saveData.req
	identifies PV's used by the saveData software,  sscan records to be
	monitored for data, and PV's whose values are to be included in all
	scan-data files.

    xxx/iocBoot/ioc*/bootParms
        a copy of the boot parameters (in case the ioc processor
        crashes in a way that erases nonvolatile memory)

4.1) xxx/iocBoot/ioc*/st.cmd
----------------------------

This is the file run by the IOC at boot time.  It loads an executable built in
the ioc directory (e.g., xxx, or xxx.munch), sets parameters to configure that
software, makes calls to that software to configure it for a particular set of
hardware, and loads databases from synApps modules.  Mostly, it sources other
.cmd files that do these same things.

This file, and the files it sources, are probably worth studying.  They are
reasonably well commented, and contain dbLoadRecords() commands for most of
the EPICS databases in synApps. 

4.2) Motors
-----------

To load more motors, add lines to the file xxx/iocBoot/ioc*/motor.substitutions.
For motors controlled by a VME board, edit vme.cmd to specify the hardware
address, etc.  For motors controlled through a serial connection, edit
serial.cmd.

If you want the new motors to work with the 'AllStop' button ("xxx:allstop.VAL"
-- see the top-level medm display xxx.adl), load the database
$(MOTOR)/db/motorUtil.db, and run the command "motorUtilInit("xxx:")".

If you want the ioc automatically to save positions and settings of the new
motors, and restore them when the crate reboots, add lines to the files
xxx/iocBoot/ioc*/auto_settings.req and xxx/iocBoot/ioc*/auto_positions.req.

4.3) Slits
----------

To use a pair of motors to control a slit, search for "2slit.db" in
xxx/iocBoot/ioc*/st.cmd, and edit the dbLoadRecords() command you'll find
there.  The example in st.cmd loads two copies of 2slit.db intended for use as
the horizontal and vertical members of a four-jaw slit.  The medm displays
2slit*.adl and 4slit*.adl are involved in these applications.

The slit database makes the following assumptions about the two motors
attached to the individual slit leaves:
1) Both of them have the same engineering units.
2) Their .VAL fields are in the same coordinate system.  I.e., if the slit is
closed, both motors have the same value.
3) The APS standard beamline coordinate system is used.  Positive Z is the beam
direction; positive Y is upward; positive X is outward from the storage ring.
So then, if I open a slit, one motor's .VAL field increases and the other's
decreases.

The 2slit.db database allows users to move either the slit virtual motors or
the actual motors, and it keeps all the readback values current regardless of
how the actual motors got moved or recalibrated. But it does not automatically
reset the slit *drive* values when the actual motors are used.  This must be
done manually, using the "SYNC" button on the 2slit.adl display.  Pressing this
button causes the database to read the actual motor drive values and set the
slit-drive values accordingly.

To recalibrate slit positions, press the "Set" button, type in the current slit
position as you want it to be called, and press the "Use" button.  This
procedure uses the "Set" buttons of both motors the slit software talks to, and
the user/dial offsets of those motors actually implement the recalibration. 

There is a new, experimental slit database in synApps which uses soft motor
records as the user/client interface.  This allows clients that know how to
control a motor also to control a slit, with some limitations.  We hope to use
soft motor records in front of other positioners (e.g. monochromators, optical
tables, insertion devices, and DAC channels) in the future.

4.4) Optical tables
-------------------
Optical tables are controlled by a custom EPICS record (the "table" record),
used in the database table.db and controlled via medm displays table*.adl.

Table virtual motors behave in much the same way as do slit virtual motors. 
However, the table software does not use user/dial offsets in the underlying
motor to implement recalibration (it can't, since it works through a nonlinear
transform).  Instead, the table maintains its own offsets for all of the six
coordinated motions it implements. Pressing the "Set" button causes new table
positions to modify the offsets instead of moving the table (which is exactly
the way motor and slit calibration works).  In addition to a "Sync" button,
which reads motor positions and calculates the table positions from them, the
table display has an "Init" button, which zeros all offsets before doing a
"sync" operation.  It also has a "Zero" button, which manipulates all the table
offsets to make the current table positions zero without moving or
recalibrating any motors.

4.5) Monochromators
-------------------
Several varieties of crystal monochromators are supported in synApps: two
constant-offset "channel-cut" monochromators, a high-resolution double-crystal
monochromator, and a spherical-grating monochromator. Most are supported by
databases paired with State Notation Language (SNL) programs, and several medm
displays.  The EPICS databases kohzuSeq.db, SNL program kohzuCtl.st, and medm
displays kohzu*.adl (also kohzu*.gif) are involved in control of two varieties
of high-heat-load monochromators.  The EPICS database hrSeq.db, SNL program
hrCtl.st, and medm displays hSeq*.adl are involbed in control of the
high-resolution double-crystal monochromator.  The spherical grating
monochromator is supported by the database SGM.db and the displays SGM*.adl.

4.6) Filters
------------
The APS standard user filters combine several motors and solenoids to control
the placement of filter material in the beam path.  The databases
filterMotor.db and filterLock.db, and the medm displays *filter*.adl are
involved in this application.

4.7) Basic run-time programming
-------------------------------
Impromptu coordinated motions and other bits of run-time programming are
handled by what we call a "userCalc" (actually just a swait record with a nice
Medm interface) or a "userTransform" (actually just a transform record with a
nice medm interface).  We normally load ten of these into each EPICS processor,
and the users type in expressions to be evaluated, and link inputs and outputs,
as needed to glue existing objects together to do what they want done at the
moment.  Here are some examples of the tasks that have been accomplished with
userCalcs and userTransforms:

- turn off hardware feedback control of a monochromator crystal when beam drops
below a user-specified level.  The userCalc monitored the EPICS PV that
contains the value of the positron beam-current, and drove a DAC channel (used
as a digital i/o bit) that enabled hardware feedback.

- support the ubiquitous theta/two-theta coordination by slaving the two-theta
motor's .VAL field to the theta motor's .VAL field.

- talk to a motor through a nonlinear transformation, e.g., energy-to-
Bragg-angle.

- close slow feedback loops -- e.g., to adjust a monochromator crystal to
suppress third-order diffraction through the high-heat-load monochromator.

- move multichannel-analyzer regions of interest automatically as the incident
beam energy changes.

- save and automatically subtract shutter-closed offsets from scaler data.

4.8) string-expression support
------------------------------
Run-time programming involving strings and/or numbers can be done with
userStringCalcs, which resemble userCalcs closely, but differ in significant
details.  A package containing two stringCalcs and an 'asyn' record (called a
"deviceCmdReply") is also available for run-time programming of simple serial-
and GPIB-device support.

4.9) array-expression support
-----------------------------
Run-time programming involving arrays and/or numbers can be done with
userArrayCalcs, which resemble userCalcs closely, but differ in significant
details.

4.10) sequence support
----------------------
Run-time programming of sequences is possible using the sseq record and related
medm displays yySseq.adl

4.11) multiple-step measurement
-------------------------------
Up to four measurement steps involving positioners, detectors, and end
calculations (e.g., to support dichroism experiments) can be done with the
4step.db database and the related medm display, 4step.adl. The entire
measurement sequence can be involved in a scan by treating the 4step database
as you would treat the scaler or mca software.


5) Using synApps
================

5.1) Boot parameters
--------------------
See xxx/iocBoot/ioc*/bootParms for sample boot parameters.

5.2) MEDM
---------
See the MEDM Operator's Manual for detailed information on the special needs of
this X11/Motif program.  I'll assume those needs have been met.

Edit the file xxx/start_epics_xxx to so it sets the environment variable
EPICS_APP to the directory that contains xxxApp.  If you plan to run MEDM on a
workstation that isn't on the same subnet as the ioc's, you'll need to
uncomment and edit the definition of the environment variable
EPICS_CA_ADDR_LIST.  In principle, you should be able to name only the
broadcast address for the subnet that contains the ioc's, but if this doesn't
work, you can put in the IP addresses of all the ioc's you want to connect
with, separated by spaces, as follows:

	setenv EPICS_CA_ADDR_LIST "164.54.53.126 164.54.53.127"

If you want to use arrays larger than 16000 bytes (e.g., MCA spectra of more
than 4000 channels, or scans of more than 2000 data points), you must set the
environment variable EPICS_CA_MAX_ARRAY_BYTES, in *both* the ioc and
workstation, to the size of the largest array you plan to send over the
network, plus the size of the extra data channel access might be asked to
include with the array.  On a Unix system, for example, you might say

	setenv EPICS_CA_MAX_ARRAY_BYTES 64008

in the ioc's st.cmd file, you'd say

	putenv "EPICS_CA_MAX_ARRAY_BYTES=64008"

To bring up the top-level medm display for synApps software, cd to xxx and type
"start_epics_xxx" (e.g., start_epics_1bma).  This script locates the
directories that might have medm-display files and includes them in the
environment variable EPICS_DISPLAY_PATH, cd's to xxxApp/op/adl, and runs MEDM
with the default top-level display file.

5.3) autosave/restore
---------------------
You must give the crate write permission to xxx/iocBoot/ioc*/autosave so it can
write the files auto_positions.sav and auto_settings.sav there.  It's also
helpful to set the autosave directory's 'group' bit so that files the crate
writes will be owned by the owner of the directory instead of by
<vxworks_user>.  Normally, I do this:

    chmod a+w,g+s autosave

To modify the list of PV's that are saved and restored, edit the files

   xxx/iocBoot/ioc*/auto_settings.req and
   xxx/iocBoot/ioc*/auto_positions.req

The autosave software is started by the lines "create_monitor_set(..." in
xxx/iocBoot/ioc*/st.cmd.  The restore happens during iocInit as a result of
function calls inserted into initHooks.o, which is loaded by
xxx/iocBoot/ioc*/st.cmd.


5.4) saveData
-------------
saveData is a CA client that monitors sscan records and saves scan data to
files on as NFS-mounted disk.  The software is configured with the file
xxx/iocBoot/ioc*/saveData.req, which needs no special attention unless you want
to modify the list of EPICS PV's whose values are to be saved with every data
file.  To do this, look for the string "[extraPV]" in the file, and edit the
list of PV's immediately following that string.  If an entry in this list
contains only the PV name, saveData will describe the PV, in the data file,
using the .DESC field of the record that contains that PV.  If a string follows
the PV name, saveData will use the string instead.


Utils executables
=================

doSed
changePrefix
------------
These are for the application developer's convenience in changing EPICS
prefixes in a user tree.  You must be in the top level of the user tree to run
changePrefix, and you should do a "gnumake clean uninstall" before running it.

Example of use:
    cd $(SYNAPPS)/ioc/1bm
    changePrefix xxx 1bma

copyAdl
-------
Look for .adl files and copy them to a directory

Example of use:
    copyAdl $SYNAPPS/support adl_files

convertIocFiles.py
------------------
This file, and its dependents are intended to help convert an ioc directory
from one version of EPICS to another, by collecting data from an existing
ioc directory, and attempting to correctly edit files in a new ioc directory.
See utils/HowToUse_convertIocFiles.txt for more.

mdautils-src.tar.gz
-------------------
This tar file contains utility programs for using data files written by
the sscan module's "saveData".  These programs were written by Dohn Arms,
and contributed to synApps.



==============================================

The custom EPICS software contained in synApps should not be assumed to be
compatible with the medm displays, burt scripts, etc. of any previous releases
of synApps.  If you pull software from here, it's probably best to pull
complete sets of related code (source, dbd, database, medm display, and
excerpts from autosave/restore request files, substitution files and st.cmd).


===============================================================================
Tim Mooney (mooney@aps.anl.gov)
Beamline Controls & Data Acquisition Group
Advanced Photon Source, Argonne National Laboratory
01/15/2009

